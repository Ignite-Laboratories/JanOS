<picture>
    <source media="(prefers-color-scheme: light)" srcset="https://raw.githubusercontent.com/Ignite-Laboratories/Enigmaneering/main/Logo%20-%20JanOS%20-%20Light.png">
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/Ignite-Laboratories/Enigmaneering/main/Logo%20-%20JanOS%20-%20Dark.png">
    <img alt="JanOS Logo" src="https://raw.githubusercontent.com/Ignite-Laboratories/Enigmaneering/main/Logo%20-%20JanOS%20-%20Light.png" width="400" >
</picture>

Welcome to JanOS - a chrono-neurological ecosystem!

## What's ARWEN?

Abstractly, an ARWEN is any Autonomous Robot With Ethical Navigation.  An algorithm is an ARWEN, a large language model
is an ARWEN, and when the two are combined with rich control surfaces like a nervous system and a heartbeat, you get
_**life itself**_.

### What's JanOS All About?

This project aims at a form of compression which, in reverse, can be used to synthesize anything in the known
universe.  As with DNA, an algorithm with as little as 64 bits of starting information could intermittently occupy
an infinite number of observably useful binary states.  Knowing _when_ to stop the algorithm is much less simple!

Arwen's current fugue is to use such an algorithm in reverse to find the starting conditions of a target file.

To do so one must perceive binary data as if a representation of _presence_ across _time_.  Binary is already processed
in logical widths of 8-bits called `bytes`, but they _technically_ could be read at several different widths.  For
instance, if the value of a byte is less than 64 it only needs 6-bits - less than 32, only 5.

The trouble is how do we _dynamically_ change the address width of each byte?

By perceiving the binary data using concepts from _**music theory**_.  If data can be read byte for byte, it's read in 
"common time" (4‚ÅÑ4). If it's being read in variable widths, a new tempo must first be observed. Verses flow through 
key changes to compose movements of information.  Even then, some bytes just don't sound right when sped up and might
need extra time to resolve their note.

## Project Structure

This repository, itself, is a placeholder to instantiate your Go workspace.  The actual code is contained in multiple
other repositories which you should clone into the directory you cloned this one into.

### Tiny
 Tiny is the heart and soul of the entire project: a library for performing variable bit-width operations on data.

### Spark
Spark is where binary compression and synthesis occur.

### Support

The "junk drawer" of JanOS:  If it's too general for the other repositories, it belongs here.  Everything from slice 
subdivision to parallel execution and random generation of "Lorem Ipsum" data.

### Fugue

Fugue is the current IgniteLabs.net website project - until more work is completed, it remains an ominous fugue.


## Enigmaneering

The ultimate goal of this entire project is to produce a book which others can use to learn the process of exploring
abstract concepts like this.  As such, I intend to keep the documentation _thorough_. =)