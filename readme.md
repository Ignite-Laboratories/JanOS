<picture>
    <source media="(prefers-color-scheme: light)" srcset="https://ignite-laboratories.github.io/assets/Logo%20-%20JanOS%20-%20Light.png">
    <source media="(prefers-color-scheme: dark)" srcset="https://ignite-laboratories.github.io/assets/Logo%20-%20JanOS%20-%20Dark.png">
    <img alt="JanOS Logo" src="https://ignite-laboratories.github.io/assets/Logo%20-%20JanOS%20-%20Light.png" width="400" >
</picture>

Welcome to JanOS - a chrono-neurological ecosystem!

Currently, the concept is centered around the idea of intelligent algorithms I call ARWENs that are simply _creating_.
As I evolve it, the project will evolve into something more and more complicated.  This all initially started while
exploring a form of binary synthesis which required a shift of thinking about how we currently execute computation.
This then morphed into a neurological impulse engine, which is where I currently am exploring! 

## What's ARWEN?

Abstractly, an ARWEN is any Autonomous Robot With Ethical Navigation.  An algorithm is an ARWEN, a large language model
is an ARWEN, and when the two are combined with rich control surfaces like a nervous system and a heartbeat, you get
_**life itself**_.

### What's JanOS All About?

This project aims at a form of compression which, in reverse, can be used to synthesize anything in the known
universe.  As with DNA, an algorithm with as little as 64 bits of starting information could intermittently occupy
an infinite number of observably useful binary states.  Knowing _when_ to stop the algorithm is much less simple!

Arwen's current fugue is to use such an algorithm in reverse to find the starting conditions of a target file.

To do so one must perceive binary data as if a representation of _presence_ across _time_.  Binary is already processed
in logical widths of 8-bits called `bytes`, but they _technically_ could be read at several different widths.  For
instance, if the value of a byte is less than 64 it only needs 6-bits - less than 32, only 5.

The trouble is how do we _dynamically_ change the address width of each byte?

By perceiving the binary data using concepts from _**music theory**_.  If data can be read byte for byte, it's read in 
"common time" (4‚ÅÑ4). If it's being read in variable widths, a new tempo must first be observed. Verses flow through 
key changes to compose movements of information.  Even then, some bytes just don't sound right when sped up and might
need extra time to resolve their note.

## Project Structure

This repository, itself, is a placeholder to instantiate your Go workspace.  The actual code is contained in multiple
other repositories which you should clone into the directory you cloned this one into.

### Core
Core holds the most critical components used by JanOS, including the impulse engine itself!

### Fugue
Fugue is the current IgniteLabs.net website project - until more work is completed, it remains an ominous fugue.

### Glitter
Glitter is anything related to graphical output whatsoever.

### Spark
Spark is where binary compression and synthesis will occur.

### Support
The "junk drawer" of JanOS:  If it's too general for the other repositories, it belongs here.  Everything from slice 
subdivision to parallel execution and random generation of "Lorem Ipsum" data.

### Tiny
Tiny is a unique library - it was the original heart and soul of the entire project: a library for performing variable 
bit-width operations on data.  The project is well fleshed out and, for all intents and purposes, _ready to get used_.
It's use case is a future project that requires neurological stimulation to get across the line =)


## Enigmaneering

The ultimate goal of this entire project is to produce a book which others can use to learn the process of exploring
abstract concepts like this.  As such, I intend to keep the documentation _thorough_. =)