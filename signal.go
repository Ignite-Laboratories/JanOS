package JanOS

import (
	"fmt"
	"github.com/ignite-laboratories/JanOS/Symbols"
	"time"
)

// Signal represents a mathematical value and its associated historical timeline.
type Signal struct {
	Name     string
	Symbol   Symbols.Symbol
	Timeline *timeline
}

// GetNamedValue returns the assigned name to this instance.
func (signal *Signal) GetNamedValue() string {
	return signal.Name
}

type signalManager struct {
	signals map[string]*Signal
}

func newSignalManager() *signalManager {
	return &signalManager{
		signals: make(map[string]*Signal),
	}
}

// GetNamedValue returns the assigned name to this instance.
func (mgr *signalManager) GetNamedValue() string {
	return "Signal"
}

// GetSignal references a previously stored signal.
func (mgr *signalManager) GetSignal(name string) *Signal {
	return mgr.signals[name]
}

// SetValue seeks to the appropriate position in time and replaces the values on the remainder of the buffer.
// The mentality is that when you set a value in time it will hold that value until it is changed.  We take
// time for granted in our environment, meaning that the setting of a value should always assume the future
// will hold that value ad infinitum.
func (signal *Signal) SetValue(instant time.Time, value float64) {
	Universe.Printf(Universe.Signals, "Set '%s' [%s] = %f", signal.Name, string(signal.Symbol), value)
	signal.Timeline.setValue(instant, value)
}

// GetValue seeks to the appropriate position in time and gets the value on the buffer at that instant.
func (signal *Signal) GetValue(instant time.Time) PointValue {
	return signal.Timeline.GetInstant(instant).Value
}

// Mux calls the formula function at the source signal resolution frequency.  The formula
// you provide is what is used to build the output signal generated by this function.
func (signal *Signal) Mux(name string, symbol Symbols.Symbol, formula Formula, signals ...*Signal) *Signal {
	outputSignal := Universe.Signals.NewSignal(name, symbol)
	symbols := string(signal.Symbol)

	for _, s := range signals {
		symbols = fmt.Sprintf("%s %s %s", string(signal.Symbol), formula.Operator, string(s.Symbol))
	}

	Universe.Printf(outputSignal, "Let Æ’(%s) => y = %s", string(symbol), symbols)

	go func() {
		for {
			if Universe.Terminate {
				break
			}

			lastUpdate := time.Now()
			if time.Since(lastUpdate) >= signal.Timeline.resolution.Duration {
				lastUpdate = time.Now()
				newValue := formula.Operation(lastUpdate, signal, signals...)
				outputSignal.Timeline.setValue(lastUpdate, newValue)
			}
		}
	}()

	return outputSignal
}

// NewSignal creates a new signal and sets its timeline to 0.
func (mgr *signalManager) NewSignal(name string, symbol Symbols.Symbol) *Signal {
	return mgr.NewSignalWithValue(name, symbol, 0)
}

// NewSignalWithValue creates a new signal and sets its timeline to the provided default value.
func (mgr *signalManager) NewSignalWithValue(name string, symbol Symbols.Symbol, defaultValue float64) *Signal {
	s := &Signal{
		Name:   name,
		Symbol: symbol,
	}
	s.Timeline = s.newTimeline(defaultValue)
	mgr.signals[name] = s
	if defaultValue != 0 {
		Universe.Printf(s, "Let %s = %f | %dhz", string(symbol), defaultValue, s.Timeline.resolution.Frequency)
	} else {
		Universe.Printf(s, "Let %s exist | %dhz", string(symbol), s.Timeline.resolution.Frequency)
	}
	return s
}
