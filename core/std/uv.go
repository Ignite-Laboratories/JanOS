// Code generated by 'gen/letters'; DO NOT EDIT.
//go:generate go run ../gen/letters -pkg std -name UV -nameL uv -cmpts U,V -cmptsL u,v -out ../std/uv.go
package std

import (
	"core/sys/atlas"
	"core/sys/name/format"
	"core/sys/num"
	"core/sys/num/bounded"
	"core/sys/support"
	"fmt"
	"strings"
)

// UV is a 2D vector of like-typed bounded.Number components.
//
// NOTE: If you'd like asymmetric types, please see UVTyped.
type UV[T num.Primitive] = UVTyped[T, T]

// UVTyped is a 2D vector of asymmetrically typed bounded.Number components.
//
// NOTE: If you'd like symmetric types, please see UV.
type UVTyped[TU num.Primitive, TV num.Primitive] struct {
	Entity
	U bounded.Number[TU]
	V bounded.Number[TV]
}

func NewUV[T num.Primitive](u T, v T) *UV[T] {
	typed := UV[T](*NewUVTyped[T, T](u, v))
	return &typed
}

func NewUVTyped[TU num.Primitive, TV num.Primitive](u TU, v TV) *UVTyped[TU, TV] {
	minU := num.MinValue[TU]()
	maxU := num.MaxValue[TU]()
	minV := num.MinValue[TV]()
	maxV := num.MaxValue[TV]()

	_v := &UVTyped[TU, TV]{}
	_v.Entity = NewEntity[format.Default]()
	_v.SetBoundaries(minU, maxU, minV, maxV)
	_v.Set(u, v)
	return _v
}

func (_v *UVTyped[TU, TV]) GetName() string {
	return _v.GivenName.Name
}

func (_v *UVTyped[TU, TV]) SetName(name string) *UVTyped[TU, TV] {
	_v.GivenName.Name = name
	return _v
}

func (_v *UVTyped[TU, TV]) Set(u TU, v TV) *UVTyped[TU, TV] {
	_ = _v.U.Set(u)
	_ = _v.V.Set(v)
	return _v
}

func (_v *UVTyped[TU, TV]) SetClamp(clamp bool) *UVTyped[TU, TV] {
	_v.U.Clamp = clamp
	_v.V.Clamp = clamp
	return _v
}

func (_v *UVTyped[TU, TV]) SetBoundaries(minU, maxU TU, minV, maxV TV) *UVTyped[TU, TV] {
	_ = _v.U.SetBoundaries(minU, maxU)
	_ = _v.V.SetBoundaries(minV, maxV)
	return _v
}

func (_v *UVTyped[TU, TV]) GetComponent(index uint) any {
	switch index {
	case 0:
		 return any(_v.U)
	case 1:
		 return any(_v.V)
	 default:
		panic(fmt.Errorf("cannot get component index %d of an UV vector", index))
	}
}

func (_v *UVTyped[TU, TV]) GetComponentByName(name string) any {
	switch strings.ToLower(name) {
	case "u":
		 return any(_v.U)
	case "v":
		 return any(_v.V)
	 default:
		panic(fmt.Errorf("cannot get component \"%s\" of an UV vector", name))
	}
}

func (_v *UVTyped[TU, TV]) SetComponent(index uint, value any) {
	switch index {
	case 0:
		 _v.U.Set(value.(TU))
	case 1:
		 _v.V.Set(value.(TV))
	 default:
		panic(fmt.Errorf("cannot set component index %d of an UV vector", index))
	}
}

func (_v *UVTyped[TU, TV]) SetComponentByName(name string, value any) {
	switch strings.ToLower(name) {
	case "u":
		 _v.U.Set(value.(TU))
	case "v":
		 _v.V.Set(value.(TV))
	 default:
		panic(fmt.Errorf("cannot set component \"%s\" of an UV vector", name))
	}
}

func (_v UVTyped[TU, TV]) String() string {
	if atlas.CompactVectors {
		return fmt.Sprintf("{u: %v, v: %v}", _v.U.String(), _v.V.String())
	}
	 if support.AllSameTypes(TU(0), TV(0)) {
		return fmt.Sprintf("uv[%T]{%v, %v}(\"%v\")", TU(0), _v.U.String(), _v.V.String(), _v.GivenName.Name)
	}
	return fmt.Sprintf("uv[%T, %T]{%v, %v}(\"%v\")", TU(0), TV(0), _v.U.String(), _v.V.String(), _v.GivenName.Name)
}

/**
Swizzling

	NOTE: This is a regular expression to find and replace swizzle functions into a one-liner if the auto formatter ever kicks in

	Find -
	func \*\((.*?)\) ([A-Z]{2,4})\(\) \((.*?)\)[ ]*\{[\n\t ]*return(.*?)[\n\t ]*\}

	Replace -
	func \*($1) $2() ($3) { return$4 }
*/

func (_v *UVTyped[TU, TV]) UU() (TU, TU) { return _v.U.Value(), _v.U.Value() }
func (_v *UVTyped[TU, TV]) UV() (TU, TV) { return _v.U.Value(), _v.V.Value() }
func (_v *UVTyped[TU, TV]) VU() (TV, TU) { return _v.V.Value(), _v.U.Value() }
func (_v *UVTyped[TU, TV]) VV() (TV, TV) { return _v.V.Value(), _v.V.Value() }
func (_v *UVTyped[TU, TV]) UUU() (TU, TU, TU) { return _v.U.Value(), _v.U.Value(), _v.U.Value() }
func (_v *UVTyped[TU, TV]) UUV() (TU, TU, TV) { return _v.U.Value(), _v.U.Value(), _v.V.Value() }
func (_v *UVTyped[TU, TV]) UVU() (TU, TV, TU) { return _v.U.Value(), _v.V.Value(), _v.U.Value() }
func (_v *UVTyped[TU, TV]) UVV() (TU, TV, TV) { return _v.U.Value(), _v.V.Value(), _v.V.Value() }
func (_v *UVTyped[TU, TV]) VUU() (TV, TU, TU) { return _v.V.Value(), _v.U.Value(), _v.U.Value() }
func (_v *UVTyped[TU, TV]) VUV() (TV, TU, TV) { return _v.V.Value(), _v.U.Value(), _v.V.Value() }
func (_v *UVTyped[TU, TV]) VVU() (TV, TV, TU) { return _v.V.Value(), _v.V.Value(), _v.U.Value() }
func (_v *UVTyped[TU, TV]) VVV() (TV, TV, TV) { return _v.V.Value(), _v.V.Value(), _v.V.Value() }
func (_v *UVTyped[TU, TV]) UUUU() (TU, TU, TU, TU) { return _v.U.Value(), _v.U.Value(), _v.U.Value(), _v.U.Value() }
func (_v *UVTyped[TU, TV]) UUUV() (TU, TU, TU, TV) { return _v.U.Value(), _v.U.Value(), _v.U.Value(), _v.V.Value() }
func (_v *UVTyped[TU, TV]) UUVU() (TU, TU, TV, TU) { return _v.U.Value(), _v.U.Value(), _v.V.Value(), _v.U.Value() }
func (_v *UVTyped[TU, TV]) UUVV() (TU, TU, TV, TV) { return _v.U.Value(), _v.U.Value(), _v.V.Value(), _v.V.Value() }
func (_v *UVTyped[TU, TV]) UVUU() (TU, TV, TU, TU) { return _v.U.Value(), _v.V.Value(), _v.U.Value(), _v.U.Value() }
func (_v *UVTyped[TU, TV]) UVUV() (TU, TV, TU, TV) { return _v.U.Value(), _v.V.Value(), _v.U.Value(), _v.V.Value() }
func (_v *UVTyped[TU, TV]) UVVU() (TU, TV, TV, TU) { return _v.U.Value(), _v.V.Value(), _v.V.Value(), _v.U.Value() }
func (_v *UVTyped[TU, TV]) UVVV() (TU, TV, TV, TV) { return _v.U.Value(), _v.V.Value(), _v.V.Value(), _v.V.Value() }
func (_v *UVTyped[TU, TV]) VUUU() (TV, TU, TU, TU) { return _v.V.Value(), _v.U.Value(), _v.U.Value(), _v.U.Value() }
func (_v *UVTyped[TU, TV]) VUUV() (TV, TU, TU, TV) { return _v.V.Value(), _v.U.Value(), _v.U.Value(), _v.V.Value() }
func (_v *UVTyped[TU, TV]) VUVU() (TV, TU, TV, TU) { return _v.V.Value(), _v.U.Value(), _v.V.Value(), _v.U.Value() }
func (_v *UVTyped[TU, TV]) VUVV() (TV, TU, TV, TV) { return _v.V.Value(), _v.U.Value(), _v.V.Value(), _v.V.Value() }
func (_v *UVTyped[TU, TV]) VVUU() (TV, TV, TU, TU) { return _v.V.Value(), _v.V.Value(), _v.U.Value(), _v.U.Value() }
func (_v *UVTyped[TU, TV]) VVUV() (TV, TV, TU, TV) { return _v.V.Value(), _v.V.Value(), _v.U.Value(), _v.V.Value() }
func (_v *UVTyped[TU, TV]) VVVU() (TV, TV, TV, TU) { return _v.V.Value(), _v.V.Value(), _v.V.Value(), _v.U.Value() }
func (_v *UVTyped[TU, TV]) VVVV() (TV, TV, TV, TV) { return _v.V.Value(), _v.V.Value(), _v.V.Value(), _v.V.Value() }
