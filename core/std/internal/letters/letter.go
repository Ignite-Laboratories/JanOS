package main

import (
	"core/sys/support"
	"errors"
	"flag"
	"fmt"
	"os"
	"strconv"
	"strings"
	"unicode"
)

type multiFlag struct{ Values []string }

func (m *multiFlag) String() string { return strings.Join(m.Values, ",") }
func (m *multiFlag) Set(v string) error {
	if strings.Contains(v, ",") {
		m.Values = append(m.Values, splitAndTrim(v)...)
	} else if v != "" {
		m.Values = append(m.Values, v)
	}
	return nil
}

var b *strings.Builder
var canSwizzle bool
var dontWrite bool
var pkg string
var fileOut string
var name string
var nameLower string
var vectorName string
var dim string
var componentsUpper []string
var componentsLower []string
var componentNames []string
var typesLike []string
var types []string
var mins []string
var maxes []string

func main() {
	//dontWrite = true
	//name = "RGB"
	//pkg = "std"
	//fileOut = "rgb.go"
	//labelsUpper = []string{"R", "G", "B"}

	parseFlags()

	b = new(strings.Builder)

	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "genletters: %v\n", err)
		os.Exit(1)
	}
}

func parseFlags() {
	var cmpts multiFlag
	var cmptsLow multiFlag

	flag.StringVar(&pkg, "pkg", "std", "")
	flag.StringVar(&name, "name", "", "")
	flag.StringVar(&nameLower, "nameL", "", "")
	flag.StringVar(&fileOut, "out", "", "")
	flag.Var(&cmpts, "cmpts", "")
	flag.Var(&cmptsLow, "cmptsL", "")
	flag.Parse()
	componentsUpper = support.Deduplicate(cmpts.Values)
	componentsLower = support.Deduplicate(cmptsLow.Values)
	canSwizzle = true

	for _, c := range componentsUpper {
		if len(c) > 1 {
			canSwizzle = false
		}
	}
}

func splitAndTrim(s string) []string {
	parts := strings.Split(s, ",")
	out := make([]string, 0, len(parts))
	for _, p := range parts {
		p = strings.TrimSpace(p)
		if p != "" {
			out = append(out, p)
		}
	}
	return out
}

func fprintf(format string, a ...any) {
	_, _ = fmt.Fprintf(b, format, a...)
}

func run() error {
	// 0 - Sanity Checks
	if len(componentsUpper) == 0 || len(componentsLower) == 0 {
		return errors.New("no components provided; use -cmpts")
	}
	if len(componentsUpper) < 1 || len(componentsUpper) > 7 {
		return fmt.Errorf("dimension %d not supported, only 1-7", len(componentsUpper))
	}
	if len(componentsLower) < 1 || len(componentsLower) > 7 {
		return fmt.Errorf("dimension %d not supported, only 1-7", len(componentsLower))
	}

	// 1 - Data Preparation
	componentsLower = make([]string, len(componentsUpper))
	typesLike = make([]string, len(componentsUpper))
	types = make([]string, len(componentsUpper))
	mins = make([]string, len(componentsUpper))
	maxes = make([]string, len(componentsUpper))
	componentNames = []string{"x", "y", "z", "w", "a", "b", "c"}
	dim = strconv.Itoa(len(componentsUpper))
	vectorName = fmt.Sprintf("VectorTyped%vD", dim)

	for i, c := range componentsUpper {
		if !support.IsAlphaNumeric(c) {
			return fmt.Errorf("label '%s' is contains alphanumeric characters not in the set of [0-9, a-z, A-Z]", c)
		}
		if len(c) <= 0 {
			return fmt.Errorf("label '%s' is empty", c)
		}
		runes := []rune(c)
		runes[0] = unicode.ToLower(runes[0])
		componentsLower[i] = string(runes)
		runes[0] = unicode.ToUpper(runes[0])
		componentsUpper[i] = string(runes)
		typesLike[i] = "T"
		types[i] = "T" + componentsUpper[i]
		mins[i] = "min" + componentsUpper[i]
		maxes[i] = "max" + componentsUpper[i]
	}

	// 2 - Generation

	buildHeader()
	buildTypes()
	buildNewFuncs()
	buildStringFunc()
	buildSetFunc()
	buildSetClampFunc()
	buildSetBoundaries()

	if canSwizzle {
		buildSwizzlePreamble()
		buildSwizzleFuncs()
	}

	// 3 - Output

	if dontWrite {
		return nil
	}

	if fileOut == "" {
		fileOut = strings.ToLower(name) + ".go"
	}
	return os.WriteFile(fileOut, []byte(b.String()), 0o644)
}

func buildHeader() {
	fprintf("// Code generated by 'internal/generators/letter'; DO NOT EDIT.\n")
	fprintf("//go:generate go run ./internal/generators/letter -pkg %s -name %s -nameL %s -cmpts %s -cmptsL %s -out %s\n", pkg, name, nameLower, strings.Join(componentsUpper, ","), strings.Join(componentsLower, ","), fileOut)
	fprintf("package %s\n\n", pkg)
	fprintf("import (\n")
	fprintf("\t\"core/sys/name/format\"\n")
	fprintf("\t\"core/sys/num\"\n")
	fprintf("\t\"core/sys/num/bounded\"\n")
	fprintf("\t\"core/sys/support\"\n")
	fprintf("\t\"fmt\"\n")
	fprintf(")\n\n")
}

func buildTypes() {
	// Symmetrically-typed
	fprintf("// %s is a %vD vector of like-typed bounded.Number components.\n", name, dim)
	fprintf("//\n")
	fprintf("// NOTE: If you'd like asymmetric types, please see %sTyped.\n", name)
	fprintf("type %s[T num.Primitive] = %sTyped[%s]\n\n", name, name, strings.Join(typesLike, ", "))

	// Asymmetrically-typed
	fprintf("// %sTyped is a %vD vector of asymmetrically typed bounded.Number components.\n", name, dim)
	fprintf("//\n")
	fprintf("// NOTE: If you'd like symmetric types, please see %s.\n", name)
	fprintf("type %sTyped[%s num.Primitive] struct {\n", name, strings.Join(types, " num.Primitive, "))
	fprintf("\tEntity\n")
	for i, c := range componentsUpper {
		fprintf("\t%s bounded.Number[%s]\n", c, types[i])
	}
	fprintf("}\n\n")
}

func buildNewFuncs() {
	// Symmetrically-typed
	fprintf("func New%s[T num.Primitive]() %s[T] {\n", name, name)
	fprintf("\treturn %s[T](New%sTyped[%s]())\n", name, name, strings.Join(typesLike, ", "))
	fprintf("}\n\n")

	// Asymmetrically-typed
	fprintf("func New%sTyped[%s num.Primitive]() %sTyped[%s] {\n", name, strings.Join(types, " num.Primitive, "), name, strings.Join(types, ", "))
	for _, c := range componentsUpper {
		fprintf("\tmin%s := num.MinValue[T%s]()\n", c, c)
		fprintf("\tmax%s := num.MaxValue[T%s]()\n", c, c)
	}
	fprintf("\n")
	fprintf("\tc := %sTyped[%s]{}\n", name, strings.Join(types, ", "))
	fprintf("\tc.Entity = NewEntity[format.Default]()\n")
	fprintf("\tc.SetBoundaries(")
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("min%s, max%s", componentsUpper[i], componentsUpper[i])
		} else {
			fprintf(", min%s, max%s", componentsUpper[i], componentsUpper[i])
		}
	}
	fprintf(")\n")
	fprintf("\treturn c\n")
	fprintf("}\n\n")
}

func buildStringFunc() {
	fprintf("func (_v %sTyped[%s]) String() string {\n", name, strings.Join(types, ", "))
	fprintf("\tif support.AllSameTypes(%s(0)) {\n", strings.Join(types, "(0), "))
	fprintf("\t\treturn fmt.Sprintf(\"%s[%%T].{", nameLower)
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("%%v")
		} else {
			fprintf(", %%v")
		}
	}
	fprintf("}(%%v)\", %s(0), ", types[0])
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("_v.%s.ValueString()", componentsUpper[i])
		} else {
			fprintf(", _v.%s.ValueString()", componentsUpper[i])
		}
	}
	fprintf(", _v.GivenName.Name)\n")
	fprintf("\t}\n")
	fprintf("\treturn fmt.Sprintf(\"%s[", nameLower)
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("%%T")
		} else {
			fprintf(", %%T")
		}
	}
	fprintf("].{")
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("%%v")
		} else {
			fprintf(", %%v")
		}
	}
	fprintf("}(%%v)\", %s(0), ", strings.Join(types, "(0), "))
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("_v.%s.ValueString()", componentsUpper[i])
		} else {
			fprintf(", _v.%s.ValueString()", componentsUpper[i])
		}
	}
	fprintf(", _v.GivenName.Name)\n")
	fprintf("}\n\n")
}

func buildSetFunc() {
	fprintf("func (_v %sTyped[%s]) Set(", name, strings.Join(types, ", "))
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("%s T%s", componentsLower[i], componentsUpper[i])
		} else {
			fprintf(", %s T%s", componentsLower[i], componentsUpper[i])
		}
	}
	fprintf(") %sTyped[%s] {\n", name, strings.Join(types, ", "))
	for i, c := range componentsUpper {
		fprintf("\t_ = _v.%s.Set(%s)\n", c, componentsLower[i])
	}
	fprintf("\treturn _v\n")
	fprintf("}\n\n")
}

func buildSetClampFunc() {
	fprintf("func (_v %sTyped[%s]) SetClamp(clamp bool) %sTyped[%s] {\n", name, strings.Join(types, ", "), name, strings.Join(types, ", "))
	for _, c := range componentsUpper {
		fprintf("\t_v.%s.Clamp = clamp\n", c)
	}
	fprintf("\treturn _v\n")
	fprintf("}\n\n")
}

func buildSetBoundaries() {
	fprintf("func (_v %sTyped[%s]) SetBoundaries(", name, strings.Join(types, ", "))
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("min%s, max%s T%s", componentsUpper[i], componentsUpper[i], componentsUpper[i])
		} else {
			fprintf(", min%s, max%s T%s", componentsUpper[i], componentsUpper[i], componentsUpper[i])
		}
	}
	fprintf(") %sTyped[%s] {\n", name, strings.Join(types, ", "))
	for _, c := range componentsUpper {
		fprintf("\t_ = _v.%s.SetBoundaries(min%s, max%s)\n", c, c, c)
	}
	fprintf("\treturn _v\n")
	fprintf("}\n\n")
}

func buildSwizzlePreamble() {
	fprintf("/**\n")
	fprintf("Swizzling\n")
	fprintf("\n")
	fprintf("\tNOTE: This is a regular expression to find and replace swizzle functions into a one-liner if the auto formatter ever kicks in\n")
	fprintf("\n")
	fprintf("\tFind -\n")
	fprintf("\tfunc \\((.*?)\\) ([A-Z]{2,4})\\(\\) \\((.*?)\\)[ ]*\\{[\\n\\t ]*return(.*?)[\\n\\t ]*\\}\n")
	fprintf("\n")
	fprintf("\tReplace -\n")
	fprintf("\tfunc ($1) $2() ($3) { return$4 }\n")
	fprintf("*/\n\n")
}

func buildSwizzleFuncs() {
	n := len(componentsUpper)
	if n < 2 {
		return
	}

	// Generate 2â€“4 letter swizzles (or up to n if n < 4)
	const maxSwizzleLen = 5
	maxLen := maxSwizzleLen
	if n < maxLen {
		maxLen = n
	}

	for k := 2; k <= maxLen; k++ {
		cur := make([]string, 0, k)

		var dfs func()
		dfs = func() {
			if len(cur) == k {
				buildSwizzleFunc(cur...)
				return
			}
			for i := 0; i < n; i++ {
				cur = append(cur, componentsUpper[i])
				dfs()
				cur = cur[:len(cur)-1]
			}
		}

		dfs()
	}
}

func buildSwizzleFunc(components ...string) {
	fprintf("func (_v %sTyped[%s]) %s() (", name, strings.Join(types, ", "), strings.Join(components, ""))
	for i, c := range components {
		if i == 0 {
			fprintf("T%s", c)
		} else {
			fprintf(", T%s", c)
		}
	}
	fprintf(") { return ")
	for i, c := range components {
		if i == 0 {
			fprintf("_v.%s.Value()", c)
		} else {
			fprintf(", _v.%s.Value()", c)
		}
	}
	fprintf(" }\n")
}
