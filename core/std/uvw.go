// Code generated by 'internal/generators/letter'; DO NOT EDIT.
//go:generate go run ./internal/generators/letter -pkg std -name UVW -nameL uvw -cmpts U,V,W -cmptsL u,v,w -out uvw.go
package std

import (
	"core/sys/name/format"
	"core/sys/num"
	"core/sys/num/bounded"
	"core/sys/support"
	"fmt"
)

// UVW is a 3D vector of like-typed bounded.Number components.
//
// NOTE: If you'd like asymmetric types, please see UVWTyped.
type UVW[T num.Primitive] = UVWTyped[T, T, T]

// UVWTyped is a 3D vector of asymmetrically typed bounded.Number components.
//
// NOTE: If you'd like symmetric types, please see UVW.
type UVWTyped[TU num.Primitive, TV num.Primitive, TW num.Primitive] struct {
	Entity
	U bounded.Number[TU]
	V bounded.Number[TV]
	W bounded.Number[TW]
}

func NewUVW[T num.Primitive]() UVW[T] {
	return UVW[T](NewUVWTyped[T, T, T]())
}

func NewUVWTyped[TU num.Primitive, TV num.Primitive, TW num.Primitive]() UVWTyped[TU, TV, TW] {
	minU := num.MinValue[TU]()
	maxU := num.MaxValue[TU]()
	minV := num.MinValue[TV]()
	maxV := num.MaxValue[TV]()
	minW := num.MinValue[TW]()
	maxW := num.MaxValue[TW]()

	c := UVWTyped[TU, TV, TW]{}
	c.Entity = NewEntity[format.Default]()
	c.SetBoundaries(minU, maxU, minV, maxV, minW, maxW)
	return c
}

func (_v UVWTyped[TU, TV, TW]) String() string {
	if support.AllSameTypes(TU(0), TV(0), TW(0)) {
		return fmt.Sprintf("uvw[%T].{%v, %v, %v}(%v)", TU(0), _v.U.ValueString(), _v.V.ValueString(), _v.W.ValueString(), _v.GivenName.Name)
	}
	return fmt.Sprintf("uvw[%T, %T, %T].{%v, %v, %v}(%v)", TU(0), TV(0), TW(0), _v.U.ValueString(), _v.V.ValueString(), _v.W.ValueString(), _v.GivenName.Name)
}

func (_v UVWTyped[TU, TV, TW]) Set(u TU, v TV, w TW) UVWTyped[TU, TV, TW] {
	_ = _v.U.Set(u)
	_ = _v.V.Set(v)
	_ = _v.W.Set(w)
	return _v
}

func (_v UVWTyped[TU, TV, TW]) SetClamp(clamp bool) UVWTyped[TU, TV, TW] {
	_v.U.Clamp = clamp
	_v.V.Clamp = clamp
	_v.W.Clamp = clamp
	return _v
}

func (_v UVWTyped[TU, TV, TW]) SetBoundaries(minU, maxU TU, minV, maxV TV, minW, maxW TW) UVWTyped[TU, TV, TW] {
	_ = _v.U.SetBoundaries(minU, maxU)
	_ = _v.V.SetBoundaries(minV, maxV)
	_ = _v.W.SetBoundaries(minW, maxW)
	return _v
}

/**
Swizzling

	NOTE: This is a regular expression to find and replace swizzle functions into a one-liner if the auto formatter ever kicks in

	Find -
	func \((.*?)\) ([A-Z]{2,4})\(\) \((.*?)\)[ ]*\{[\n\t ]*return(.*?)[\n\t ]*\}

	Replace -
	func ($1) $2() ($3) { return$4 }
*/

func (_v UVWTyped[TU, TV, TW]) UU() (TU, TU) { return _v.U.Value(), _v.U.Value() }
func (_v UVWTyped[TU, TV, TW]) UV() (TU, TV) { return _v.U.Value(), _v.V.Value() }
func (_v UVWTyped[TU, TV, TW]) UW() (TU, TW) { return _v.U.Value(), _v.W.Value() }
func (_v UVWTyped[TU, TV, TW]) VU() (TV, TU) { return _v.V.Value(), _v.U.Value() }
func (_v UVWTyped[TU, TV, TW]) VV() (TV, TV) { return _v.V.Value(), _v.V.Value() }
func (_v UVWTyped[TU, TV, TW]) VW() (TV, TW) { return _v.V.Value(), _v.W.Value() }
func (_v UVWTyped[TU, TV, TW]) WU() (TW, TU) { return _v.W.Value(), _v.U.Value() }
func (_v UVWTyped[TU, TV, TW]) WV() (TW, TV) { return _v.W.Value(), _v.V.Value() }
func (_v UVWTyped[TU, TV, TW]) WW() (TW, TW) { return _v.W.Value(), _v.W.Value() }
func (_v UVWTyped[TU, TV, TW]) UUU() (TU, TU, TU) { return _v.U.Value(), _v.U.Value(), _v.U.Value() }
func (_v UVWTyped[TU, TV, TW]) UUV() (TU, TU, TV) { return _v.U.Value(), _v.U.Value(), _v.V.Value() }
func (_v UVWTyped[TU, TV, TW]) UUW() (TU, TU, TW) { return _v.U.Value(), _v.U.Value(), _v.W.Value() }
func (_v UVWTyped[TU, TV, TW]) UVU() (TU, TV, TU) { return _v.U.Value(), _v.V.Value(), _v.U.Value() }
func (_v UVWTyped[TU, TV, TW]) UVV() (TU, TV, TV) { return _v.U.Value(), _v.V.Value(), _v.V.Value() }
func (_v UVWTyped[TU, TV, TW]) UVW() (TU, TV, TW) { return _v.U.Value(), _v.V.Value(), _v.W.Value() }
func (_v UVWTyped[TU, TV, TW]) UWU() (TU, TW, TU) { return _v.U.Value(), _v.W.Value(), _v.U.Value() }
func (_v UVWTyped[TU, TV, TW]) UWV() (TU, TW, TV) { return _v.U.Value(), _v.W.Value(), _v.V.Value() }
func (_v UVWTyped[TU, TV, TW]) UWW() (TU, TW, TW) { return _v.U.Value(), _v.W.Value(), _v.W.Value() }
func (_v UVWTyped[TU, TV, TW]) VUU() (TV, TU, TU) { return _v.V.Value(), _v.U.Value(), _v.U.Value() }
func (_v UVWTyped[TU, TV, TW]) VUV() (TV, TU, TV) { return _v.V.Value(), _v.U.Value(), _v.V.Value() }
func (_v UVWTyped[TU, TV, TW]) VUW() (TV, TU, TW) { return _v.V.Value(), _v.U.Value(), _v.W.Value() }
func (_v UVWTyped[TU, TV, TW]) VVU() (TV, TV, TU) { return _v.V.Value(), _v.V.Value(), _v.U.Value() }
func (_v UVWTyped[TU, TV, TW]) VVV() (TV, TV, TV) { return _v.V.Value(), _v.V.Value(), _v.V.Value() }
func (_v UVWTyped[TU, TV, TW]) VVW() (TV, TV, TW) { return _v.V.Value(), _v.V.Value(), _v.W.Value() }
func (_v UVWTyped[TU, TV, TW]) VWU() (TV, TW, TU) { return _v.V.Value(), _v.W.Value(), _v.U.Value() }
func (_v UVWTyped[TU, TV, TW]) VWV() (TV, TW, TV) { return _v.V.Value(), _v.W.Value(), _v.V.Value() }
func (_v UVWTyped[TU, TV, TW]) VWW() (TV, TW, TW) { return _v.V.Value(), _v.W.Value(), _v.W.Value() }
func (_v UVWTyped[TU, TV, TW]) WUU() (TW, TU, TU) { return _v.W.Value(), _v.U.Value(), _v.U.Value() }
func (_v UVWTyped[TU, TV, TW]) WUV() (TW, TU, TV) { return _v.W.Value(), _v.U.Value(), _v.V.Value() }
func (_v UVWTyped[TU, TV, TW]) WUW() (TW, TU, TW) { return _v.W.Value(), _v.U.Value(), _v.W.Value() }
func (_v UVWTyped[TU, TV, TW]) WVU() (TW, TV, TU) { return _v.W.Value(), _v.V.Value(), _v.U.Value() }
func (_v UVWTyped[TU, TV, TW]) WVV() (TW, TV, TV) { return _v.W.Value(), _v.V.Value(), _v.V.Value() }
func (_v UVWTyped[TU, TV, TW]) WVW() (TW, TV, TW) { return _v.W.Value(), _v.V.Value(), _v.W.Value() }
func (_v UVWTyped[TU, TV, TW]) WWU() (TW, TW, TU) { return _v.W.Value(), _v.W.Value(), _v.U.Value() }
func (_v UVWTyped[TU, TV, TW]) WWV() (TW, TW, TV) { return _v.W.Value(), _v.W.Value(), _v.V.Value() }
func (_v UVWTyped[TU, TV, TW]) WWW() (TW, TW, TW) { return _v.W.Value(), _v.W.Value(), _v.W.Value() }
