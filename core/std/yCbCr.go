// Code generated by 'gen/letters'; DO NOT EDIT.
//go:generate go run ../gen/letters -pkg std -name YCbCr -nameL yCbCr -cmpts Y,Cb,Cr -cmptsL y,cb,cr -out ../std/yCbCr.go
package std

import (
	"core/sys/atlas"
	"core/sys/name/format"
	"core/sys/num"
	"core/sys/num/bounded"
	"core/sys/support"
	"fmt"
	"strings"
)

// YCbCr is a 3D vector of like-typed bounded.Number components.
//
// NOTE: If you'd like asymmetric types, please see YCbCrTyped.
type YCbCr[T num.Primitive] = YCbCrTyped[T, T, T]

// YCbCrTyped is a 3D vector of asymmetrically typed bounded.Number components.
//
// NOTE: If you'd like symmetric types, please see YCbCr.
type YCbCrTyped[TY num.Primitive, TCb num.Primitive, TCr num.Primitive] struct {
	Entity
	Y bounded.Number[TY]
	Cb bounded.Number[TCb]
	Cr bounded.Number[TCr]
}

func NewYCbCr[T num.Primitive](y T, cb T, cr T) *YCbCr[T] {
	typed := YCbCr[T](*NewYCbCrTyped[T, T, T](y, cb, cr))
	return &typed
}

func NewYCbCrTyped[TY num.Primitive, TCb num.Primitive, TCr num.Primitive](y TY, cb TCb, cr TCr) *YCbCrTyped[TY, TCb, TCr] {
	minY := num.MinValue[TY]()
	maxY := num.MaxValue[TY]()
	minCb := num.MinValue[TCb]()
	maxCb := num.MaxValue[TCb]()
	minCr := num.MinValue[TCr]()
	maxCr := num.MaxValue[TCr]()

	_v := &YCbCrTyped[TY, TCb, TCr]{}
	_v.Entity = NewEntity[format.Default]()
	_v.SetBoundaries(minY, maxY, minCb, maxCb, minCr, maxCr)
	_v.Set(y, cb, cr)
	return _v
}

func (_v *YCbCrTyped[TY, TCb, TCr]) GetName() string {
	return _v.GivenName.Name
}

func (_v *YCbCrTyped[TY, TCb, TCr]) SetName(name string) *YCbCrTyped[TY, TCb, TCr] {
	_v.GivenName.Name = name
	return _v
}

func (_v *YCbCrTyped[TY, TCb, TCr]) Set(y TY, cb TCb, cr TCr) *YCbCrTyped[TY, TCb, TCr] {
	_ = _v.Y.Set(y)
	_ = _v.Cb.Set(cb)
	_ = _v.Cr.Set(cr)
	return _v
}

func (_v *YCbCrTyped[TY, TCb, TCr]) SetClamp(clamp bool) *YCbCrTyped[TY, TCb, TCr] {
	_v.Y.Clamp = clamp
	_v.Cb.Clamp = clamp
	_v.Cr.Clamp = clamp
	return _v
}

func (_v *YCbCrTyped[TY, TCb, TCr]) SetBoundaries(minY, maxY TY, minCb, maxCb TCb, minCr, maxCr TCr) *YCbCrTyped[TY, TCb, TCr] {
	_ = _v.Y.SetBoundaries(minY, maxY)
	_ = _v.Cb.SetBoundaries(minCb, maxCb)
	_ = _v.Cr.SetBoundaries(minCr, maxCr)
	return _v
}

func (_v *YCbCrTyped[TY, TCb, TCr]) GetComponent(index uint) any {
	switch index {
	case 0:
		 return any(_v.Y)
	case 1:
		 return any(_v.Cb)
	case 2:
		 return any(_v.Cr)
	 default:
		panic(fmt.Errorf("cannot get component index %d of an YCbCr vector", index))
	}
}

func (_v *YCbCrTyped[TY, TCb, TCr]) GetComponentByName(name string) any {
	switch strings.ToLower(name) {
	case "y":
		 return any(_v.Y)
	case "cb":
		 return any(_v.Cb)
	case "cr":
		 return any(_v.Cr)
	 default:
		panic(fmt.Errorf("cannot get component \"%s\" of an YCbCr vector", name))
	}
}

func (_v *YCbCrTyped[TY, TCb, TCr]) SetComponent(index uint, value any) {
	switch index {
	case 0:
		 _v.Y.Set(value.(TY))
	case 1:
		 _v.Cb.Set(value.(TCb))
	case 2:
		 _v.Cr.Set(value.(TCr))
	 default:
		panic(fmt.Errorf("cannot set component index %d of an YCbCr vector", index))
	}
}

func (_v *YCbCrTyped[TY, TCb, TCr]) SetComponentByName(name string, value any) {
	switch strings.ToLower(name) {
	case "y":
		 _v.Y.Set(value.(TY))
	case "cb":
		 _v.Cb.Set(value.(TCb))
	case "cr":
		 _v.Cr.Set(value.(TCr))
	 default:
		panic(fmt.Errorf("cannot set component \"%s\" of an YCbCr vector", name))
	}
}

func (_v YCbCrTyped[TY, TCb, TCr]) String() string {
	if atlas.CompactVectors {
		return fmt.Sprintf("{y: %v, cb: %v, cr: %v}", _v.Y.String(), _v.Cb.String(), _v.Cr.String())
	}
	 if support.AllSameTypes(TY(0), TCb(0), TCr(0)) {
		return fmt.Sprintf("yCbCr[%T]{%v, %v, %v}(\"%v\")", TY(0), _v.Y.String(), _v.Cb.String(), _v.Cr.String(), _v.GivenName.Name)
	}
	return fmt.Sprintf("yCbCr[%T, %T, %T]{%v, %v, %v}(\"%v\")", TY(0), TCb(0), TCr(0), _v.Y.String(), _v.Cb.String(), _v.Cr.String(), _v.GivenName.Name)
}

