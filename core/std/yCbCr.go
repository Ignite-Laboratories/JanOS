// Code generated by 'gen/letters'; DO NOT EDIT.
//go:generate go run ../gen/letters -pkg std -name YCbCr -nameL yCbCr -cmpts Y,Cb,Cr -cmptsL y,cb,cr -out ../std/yCbCr.go
package std

import (
	"core/sys/atlas"
	"core/sys/name/format"
	"core/sys/num"
	"core/sys/num/bounded"
	"core/sys/support"
	"fmt"
	"strings"
)

// YCbCr is a 3D vector of like-typed bounded.Numeric components.
//
// NOTE: If you'd like asymmetric types, please see YCbCrTyped.
type YCbCr[T num.Primitive] = YCbCrTyped[T, T, T]

// YCbCrTyped is a 3D vector of asymmetrically typed bounded.Numeric components.
//
// NOTE: If you'd like symmetric types, please see YCbCr.
type YCbCrTyped[TY num.Primitive, TCb num.Primitive, TCr num.Primitive] struct {
	Entity
	Y bounded.Numeric[TY]
	Cb bounded.Numeric[TCb]
	Cr bounded.Numeric[TCr]
}

func NewYCbCr[T num.Primitive](y T, cb T, cr T) *YCbCr[T] {
	typed := YCbCr[T](*NewYCbCrTyped[T, T, T](y, cb, cr))
	return &typed
}

func NewYCbCrTyped[TY num.Primitive, TCb num.Primitive, TCr num.Primitive](y TY, cb TCb, cr TCr) *YCbCrTyped[TY, TCb, TCr] {
	minY := num.MinValue[TY]()
	maxY := num.MaxValue[TY]()
	minCb := num.MinValue[TCb]()
	maxCb := num.MaxValue[TCb]()
	minCr := num.MinValue[TCr]()
	maxCr := num.MaxValue[TCr]()

	_v := &YCbCrTyped[TY, TCb, TCr]{}
	_v.Entity = NewEntity[format.Default]()
	_v.SetBoundaries(minY, maxY, minCb, maxCb, minCr, maxCr)
	_v.Set(y, cb, cr)
	return _v
}

func (_v *YCbCrTyped[TY, TCb, TCr]) Name() string {
	return _v.GivenName.Name
}

func (_v *YCbCrTyped[TY, TCb, TCr]) SetName(name string) *YCbCrTyped[TY, TCb, TCr] {
	_v.GivenName.Name = name
	return _v
}

func (_v *YCbCrTyped[TY, TCb, TCr]) Set(y TY, cb TCb, cr TCr) *YCbCrTyped[TY, TCb, TCr] {
	_ = _v.Y.Set(y)
	_ = _v.Cb.Set(cb)
	_ = _v.Cr.Set(cr)
	return _v
}

func (_v *YCbCrTyped[TY, TCb, TCr]) SetClamp(clamp bool) *YCbCrTyped[TY, TCb, TCr] {
	_v.Y.Clamp = clamp
	_v.Cb.Clamp = clamp
	_v.Cr.Clamp = clamp
	return _v
}

func (_v *YCbCrTyped[TY, TCb, TCr]) SetBoundaries(minY, maxY TY, minCb, maxCb TCb, minCr, maxCr TCr) *YCbCrTyped[TY, TCb, TCr] {
	_ = _v.Y.SetBoundaries(minY, maxY)
	_ = _v.Cb.SetBoundaries(minCb, maxCb)
	_ = _v.Cr.SetBoundaries(minCr, maxCr)
	return _v
}

func (_v *YCbCrTyped[TY, TCb, TCr]) Component(index uint) (bounded.INumeric, error) {
	switch index {
	case 0:
		return &_v.Y, nil
	case 1:
		return &_v.Cb, nil
	case 2:
		return &_v.Cr, nil
	default:
		return nil, fmt.Errorf("cannot get component index %d of an YCbCr vector", index)
	}
}

func (_v *YCbCrTyped[TY, TCb, TCr]) Components() []bounded.INumeric {
	return []bounded.INumeric{&_v.Y, &_v.Cb, &_v.Cr}
}

func (_v *YCbCrTyped[TY, TCb, TCr]) ComponentByName(name string) (bounded.INumeric, error) {
	switch strings.ToLower(name) {
	case "y":
		return &_v.Y, nil
	case "cb":
		return &_v.Cb, nil
	case "cr":
		return &_v.Cr, nil
	default:
		return nil, fmt.Errorf("cannot get component \"%s\" of an YCbCr vector", name)
	}
}

func (_v *YCbCrTyped[TY, TCb, TCr]) ComponentLen() uint {
	return 3
}

func (_v *YCbCrTyped[TY, TCb, TCr]) SetComponent(index uint, value any) error {
	switch index {
	case 0:
		 _v.Y.Set(value.(TY))
	case 1:
		 _v.Cb.Set(value.(TCb))
	case 2:
		 _v.Cr.Set(value.(TCr))
	default:
		return fmt.Errorf("cannot set component index %d of an YCbCr vector", index)
	}
	return nil
}

func (_v *YCbCrTyped[TY, TCb, TCr]) SetComponents(values []any) error {
	if len(values) != 3 {
		return fmt.Errorf("cannot set %d components of 3D vector YCbCr", len(values), )
	}
	if _, ok := values[0].(TY); !ok {
		return fmt.Errorf("expected type %T for component Y, got type %T", TY(0), values[0])	}
	if _, ok := values[1].(TCb); !ok {
		return fmt.Errorf("expected type %T for component Cb, got type %T", TCb(0), values[1])	}
	if _, ok := values[2].(TCr); !ok {
		return fmt.Errorf("expected type %T for component Cr, got type %T", TCr(0), values[2])	}
	_v.Y.Set(values[0].(TY))
	_v.Cb.Set(values[1].(TCb))
	_v.Cr.Set(values[2].(TCr))
	return nil
}

func (_v *YCbCrTyped[TY, TCb, TCr]) SetComponentByName(name string, value any) error {
	switch strings.ToLower(name) {
	case "y":
		 _v.Y.Set(value.(TY))
	case "cb":
		 _v.Cb.Set(value.(TCb))
	case "cr":
		 _v.Cr.Set(value.(TCr))
	default:
		return fmt.Errorf("cannot set component \"%s\" of an YCbCr vector", name)
	}
	return nil
}

func (_v YCbCrTyped[TY, TCb, TCr]) String() string {
	if atlas.CompactVectors {
		return fmt.Sprintf("{y: %v, cb: %v, cr: %v}", _v.Y.String(), _v.Cb.String(), _v.Cr.String())
	}
	 if support.AllSameTypes(TY(0), TCb(0), TCr(0)) {
		return fmt.Sprintf("yCbCr[%T]{%v, %v, %v}(\"%v\")", TY(0), _v.Y.String(), _v.Cb.String(), _v.Cr.String(), _v.GivenName.Name)
	}
	return fmt.Sprintf("yCbCr[%T, %T, %T]{%v, %v, %v}(\"%v\")", TY(0), TCb(0), TCr(0), _v.Y.String(), _v.Cb.String(), _v.Cr.String(), _v.GivenName.Name)
}

