// Code generated by 'internal/generators/letter'; DO NOT EDIT.
//go:generate go run ./internal/generators/letter -pkg std -name XYZ -nameL xyz -cmpts X,Y,Z -cmptsL x,y,z -out ../xyz.go
package std

import (
	"core/sys/name/format"
	"core/sys/num"
	"core/sys/num/bounded"
	"core/sys/support"
	"fmt"
)

// XYZ is a 3D vector of like-typed bounded.Number components.
//
// NOTE: If you'd like asymmetric types, please see XYZTyped.
type XYZ[T num.Primitive] = XYZTyped[T, T, T]

// XYZTyped is a 3D vector of asymmetrically typed bounded.Number components.
//
// NOTE: If you'd like symmetric types, please see XYZ.
type XYZTyped[TX num.Primitive, TY num.Primitive, TZ num.Primitive] struct {
	Entity
	X bounded.Number[TX]
	Y bounded.Number[TY]
	Z bounded.Number[TZ]
}

func NewXYZ[T num.Primitive]() XYZ[T] {
	return XYZ[T](NewXYZTyped[T, T, T]())
}

func NewXYZTyped[TX num.Primitive, TY num.Primitive, TZ num.Primitive]() XYZTyped[TX, TY, TZ] {
	minX := num.MinValue[TX]()
	maxX := num.MaxValue[TX]()
	minY := num.MinValue[TY]()
	maxY := num.MaxValue[TY]()
	minZ := num.MinValue[TZ]()
	maxZ := num.MaxValue[TZ]()

	c := XYZTyped[TX, TY, TZ]{}
	c.Entity = NewEntity[format.Default]()
	c.SetBoundaries(minX, maxX, minY, maxY, minZ, maxZ)
	return c
}

func (_v XYZTyped[TX, TY, TZ]) String() string {
	if support.AllSameTypes(TX(0), TY(0), TZ(0)) {
		return fmt.Sprintf("xyz[%T].{%v, %v, %v}(%v)", TX(0), _v.X.ValueString(), _v.Y.ValueString(), _v.Z.ValueString(), _v.GivenName.Name)
	}
	return fmt.Sprintf("xyz[%T, %T, %T].{%v, %v, %v}(%v)", TX(0), TY(0), TZ(0), _v.X.ValueString(), _v.Y.ValueString(), _v.Z.ValueString(), _v.GivenName.Name)
}

func (_v XYZTyped[TX, TY, TZ]) Set(x TX, y TY, z TZ) XYZTyped[TX, TY, TZ] {
	_ = _v.X.Set(x)
	_ = _v.Y.Set(y)
	_ = _v.Z.Set(z)
	return _v
}

func (_v XYZTyped[TX, TY, TZ]) SetClamp(clamp bool) XYZTyped[TX, TY, TZ] {
	_v.X.Clamp = clamp
	_v.Y.Clamp = clamp
	_v.Z.Clamp = clamp
	return _v
}

func (_v XYZTyped[TX, TY, TZ]) SetBoundaries(minX, maxX TX, minY, maxY TY, minZ, maxZ TZ) XYZTyped[TX, TY, TZ] {
	_ = _v.X.SetBoundaries(minX, maxX)
	_ = _v.Y.SetBoundaries(minY, maxY)
	_ = _v.Z.SetBoundaries(minZ, maxZ)
	return _v
}

/**
Swizzling

	NOTE: This is a regular expression to find and replace swizzle functions into a one-liner if the auto formatter ever kicks in

	Find -
	func \((.*?)\) ([A-Z]{2,4})\(\) \((.*?)\)[ ]*\{[\n\t ]*return(.*?)[\n\t ]*\}

	Replace -
	func ($1) $2() ($3) { return$4 }
*/

func (_v XYZTyped[TX, TY, TZ]) XX() (TX, TX) { return _v.X.Value(), _v.X.Value() }
func (_v XYZTyped[TX, TY, TZ]) XY() (TX, TY) { return _v.X.Value(), _v.Y.Value() }
func (_v XYZTyped[TX, TY, TZ]) XZ() (TX, TZ) { return _v.X.Value(), _v.Z.Value() }
func (_v XYZTyped[TX, TY, TZ]) YX() (TY, TX) { return _v.Y.Value(), _v.X.Value() }
func (_v XYZTyped[TX, TY, TZ]) YY() (TY, TY) { return _v.Y.Value(), _v.Y.Value() }
func (_v XYZTyped[TX, TY, TZ]) YZ() (TY, TZ) { return _v.Y.Value(), _v.Z.Value() }
func (_v XYZTyped[TX, TY, TZ]) ZX() (TZ, TX) { return _v.Z.Value(), _v.X.Value() }
func (_v XYZTyped[TX, TY, TZ]) ZY() (TZ, TY) { return _v.Z.Value(), _v.Y.Value() }
func (_v XYZTyped[TX, TY, TZ]) ZZ() (TZ, TZ) { return _v.Z.Value(), _v.Z.Value() }
func (_v XYZTyped[TX, TY, TZ]) XXX() (TX, TX, TX) { return _v.X.Value(), _v.X.Value(), _v.X.Value() }
func (_v XYZTyped[TX, TY, TZ]) XXY() (TX, TX, TY) { return _v.X.Value(), _v.X.Value(), _v.Y.Value() }
func (_v XYZTyped[TX, TY, TZ]) XXZ() (TX, TX, TZ) { return _v.X.Value(), _v.X.Value(), _v.Z.Value() }
func (_v XYZTyped[TX, TY, TZ]) XYX() (TX, TY, TX) { return _v.X.Value(), _v.Y.Value(), _v.X.Value() }
func (_v XYZTyped[TX, TY, TZ]) XYY() (TX, TY, TY) { return _v.X.Value(), _v.Y.Value(), _v.Y.Value() }
func (_v XYZTyped[TX, TY, TZ]) XYZ() (TX, TY, TZ) { return _v.X.Value(), _v.Y.Value(), _v.Z.Value() }
func (_v XYZTyped[TX, TY, TZ]) XZX() (TX, TZ, TX) { return _v.X.Value(), _v.Z.Value(), _v.X.Value() }
func (_v XYZTyped[TX, TY, TZ]) XZY() (TX, TZ, TY) { return _v.X.Value(), _v.Z.Value(), _v.Y.Value() }
func (_v XYZTyped[TX, TY, TZ]) XZZ() (TX, TZ, TZ) { return _v.X.Value(), _v.Z.Value(), _v.Z.Value() }
func (_v XYZTyped[TX, TY, TZ]) YXX() (TY, TX, TX) { return _v.Y.Value(), _v.X.Value(), _v.X.Value() }
func (_v XYZTyped[TX, TY, TZ]) YXY() (TY, TX, TY) { return _v.Y.Value(), _v.X.Value(), _v.Y.Value() }
func (_v XYZTyped[TX, TY, TZ]) YXZ() (TY, TX, TZ) { return _v.Y.Value(), _v.X.Value(), _v.Z.Value() }
func (_v XYZTyped[TX, TY, TZ]) YYX() (TY, TY, TX) { return _v.Y.Value(), _v.Y.Value(), _v.X.Value() }
func (_v XYZTyped[TX, TY, TZ]) YYY() (TY, TY, TY) { return _v.Y.Value(), _v.Y.Value(), _v.Y.Value() }
func (_v XYZTyped[TX, TY, TZ]) YYZ() (TY, TY, TZ) { return _v.Y.Value(), _v.Y.Value(), _v.Z.Value() }
func (_v XYZTyped[TX, TY, TZ]) YZX() (TY, TZ, TX) { return _v.Y.Value(), _v.Z.Value(), _v.X.Value() }
func (_v XYZTyped[TX, TY, TZ]) YZY() (TY, TZ, TY) { return _v.Y.Value(), _v.Z.Value(), _v.Y.Value() }
func (_v XYZTyped[TX, TY, TZ]) YZZ() (TY, TZ, TZ) { return _v.Y.Value(), _v.Z.Value(), _v.Z.Value() }
func (_v XYZTyped[TX, TY, TZ]) ZXX() (TZ, TX, TX) { return _v.Z.Value(), _v.X.Value(), _v.X.Value() }
func (_v XYZTyped[TX, TY, TZ]) ZXY() (TZ, TX, TY) { return _v.Z.Value(), _v.X.Value(), _v.Y.Value() }
func (_v XYZTyped[TX, TY, TZ]) ZXZ() (TZ, TX, TZ) { return _v.Z.Value(), _v.X.Value(), _v.Z.Value() }
func (_v XYZTyped[TX, TY, TZ]) ZYX() (TZ, TY, TX) { return _v.Z.Value(), _v.Y.Value(), _v.X.Value() }
func (_v XYZTyped[TX, TY, TZ]) ZYY() (TZ, TY, TY) { return _v.Z.Value(), _v.Y.Value(), _v.Y.Value() }
func (_v XYZTyped[TX, TY, TZ]) ZYZ() (TZ, TY, TZ) { return _v.Z.Value(), _v.Y.Value(), _v.Z.Value() }
func (_v XYZTyped[TX, TY, TZ]) ZZX() (TZ, TZ, TX) { return _v.Z.Value(), _v.Z.Value(), _v.X.Value() }
func (_v XYZTyped[TX, TY, TZ]) ZZY() (TZ, TZ, TY) { return _v.Z.Value(), _v.Z.Value(), _v.Y.Value() }
func (_v XYZTyped[TX, TY, TZ]) ZZZ() (TZ, TZ, TZ) { return _v.Z.Value(), _v.Z.Value(), _v.Z.Value() }
