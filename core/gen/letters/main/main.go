package main

import (
	"core/sys/support"
	"errors"
	"flag"
	"fmt"
	"os"
	"strconv"
	"strings"
	"unicode"
)

const swizzleMax = 4

type multiFlag struct{ Values []string }

func (m *multiFlag) String() string { return strings.Join(m.Values, ",") }
func (m *multiFlag) Set(v string) error {
	if strings.Contains(v, ",") {
		m.Values = append(m.Values, splitAndTrim(v)...)
	} else if v != "" {
		m.Values = append(m.Values, v)
	}
	return nil
}

var b *strings.Builder
var dontWrite bool
var pkg string
var fileOut string
var name string
var nameTyped string
var nameLower string
var nameLowerTyped string
var vectorName string
var dim string
var componentsUpper []string
var componentsLower []string
var componentNames []string
var typesLike []string
var types []string
var mins []string
var maxes []string

func main() {
	//dontWrite = true
	//name = "RGB"
	//pkg = "std"
	//fileOut = "rgb.go"
	//labelsUpper = []string{"R", "G", "B"}

	parseFlags()

	b = new(strings.Builder)

	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "letter generation: %v\n", err)
		os.Exit(1)
	}
}

func parseFlags() {
	var cmpts multiFlag
	var cmptsLow multiFlag

	flag.StringVar(&pkg, "pkg", "std", "")
	flag.StringVar(&name, "name", "", "")
	flag.StringVar(&nameLower, "nameL", "", "")
	flag.StringVar(&fileOut, "out", "", "")
	flag.Var(&cmpts, "cmpts", "")
	flag.Var(&cmptsLow, "cmptsL", "")
	flag.Parse()
	componentsUpper = support.Deduplicate(cmpts.Values)
	componentsLower = support.Deduplicate(cmptsLow.Values)

	nameTyped = name + "Typed"
	nameLowerTyped = nameLower + "Typed"

	if len(componentsUpper) == 1 {
		nameTyped = name
		nameLowerTyped = nameLower
	}
}

func setComponentCasing(i int, c string) {
	if !support.IsAlphaNumeric(c) {
		panic(fmt.Errorf("label '%s' is contains alphanumeric characters not in the set of [0-9, a-z, A-Z]", c))
	}
	if len(c) <= 0 {
		panic(fmt.Errorf("label '%s' is empty", c))
	}

	lower := support.SetCase(c, false, 0)
	for ii := 1; ii < len(c); ii++ {
		lower = support.SetCase(c, true, ii)
	}

	upper := support.SetCase(c, true, 0)
	for ii := 1; ii < len(c); ii++ {
		lower = support.SetCase(c, false, ii)
	}

	componentsUpper[i] = upper
	componentsLower[i] = lower
}

func changeIndexCase(s string, i int, upper bool) string {
	runes := []rune(s)
	if upper {
		runes[i] = unicode.ToUpper(runes[i])
	} else {
		runes[i] = unicode.ToLower(runes[i])
	}
	return string(runes)
}

func splitAndTrim(s string) []string {
	parts := strings.Split(s, ",")
	out := make([]string, 0, len(parts))
	for _, p := range parts {
		p = strings.TrimSpace(p)
		if p != "" {
			out = append(out, p)
		}
	}
	return out
}

func fprintf(format string, a ...any) {
	_, _ = fmt.Fprintf(b, format, a...)
}

func run() error {
	// 0 - Sanity Checks
	if len(componentsUpper) == 0 || len(componentsLower) == 0 {
		return errors.New("no components provided; use -cmpts")
	}
	if len(componentsUpper) < 1 || len(componentsUpper) > 7 {
		return fmt.Errorf("dimension %d not supported, only 1-7", len(componentsUpper))
	}
	if len(componentsLower) < 1 || len(componentsLower) > 7 {
		return fmt.Errorf("dimension %d not supported, only 1-7", len(componentsLower))
	}

	// 1 - Data Preparation
	componentsLower = make([]string, len(componentsUpper))
	typesLike = make([]string, len(componentsUpper))
	types = make([]string, len(componentsUpper))
	mins = make([]string, len(componentsUpper))
	maxes = make([]string, len(componentsUpper))
	componentNames = []string{"x", "y", "z", "w", "a", "b", "c"}
	dim = strconv.Itoa(len(componentsUpper))
	vectorName = fmt.Sprintf("VectorTyped%vD", dim)

	for i, c := range componentsUpper {
		setComponentCasing(i, c)
		typesLike[i] = "T"
		types[i] = "T" + componentsUpper[i]
		mins[i] = "min" + componentsUpper[i]
		maxes[i] = "max" + componentsUpper[i]
	}

	// 2 - Generation

	buildHeader()
	buildTypes()

	buildNewFuncs()

	buildName()
	buildSetName()

	buildSetFunc()
	buildSetClampFunc()
	buildSetBoundaries()

	buildComponent()
	buildComponents()
	buildComponentByName()
	buildComponentLen()

	buildSetComponent()
	buildSetComponents()
	buildSetComponentByName()

	buildStringFunc()

	buildSwizzleFuncs()

	// 3 - Output

	if dontWrite {
		return nil
	}

	if fileOut == "" {
		fileOut = strings.ToLower(name) + ".go"
	}
	return os.WriteFile(fileOut, []byte(b.String()), 0o644)
}

func buildHeader() {
	fprintf("// Code generated by 'gen/letters/main'; DO NOT EDIT.\n")
	fprintf("//go:generate go run ../gen/letters/main -pkg %s -name %s -nameL %s -cmpts %s -cmptsL %s -out %s\n", pkg, name, nameLower, strings.Join(componentsUpper, ","), strings.Join(componentsLower, ","), fileOut)
	fprintf("package %s\n\n", pkg)
	fprintf("import (\n")
	fprintf("\t\"core/sys/atlas\"\n")
	if name[0] != '_' {
		fprintf("\t\"core/sys/given/format\"\n")
	}
	fprintf("\t\"core/sys/num\"\n")
	fprintf("\t\"core/sys/num/bounded\"\n")
	fprintf("\t\"core/sys/support\"\n")
	fprintf("\t\"fmt\"\n")
	fprintf("\t\"strings\"\n")
	fprintf(")\n\n")
}

func buildTypes() {
	// Symmetrically-typed
	if len(componentsUpper) > 1 {
		fprintf("// %s is a %vD vector of like-typed bounded.Numeric components.\n", name, dim)
		fprintf("//\n")
		fprintf("// NOTE: If you'd like asymmetric types, please see %sTyped.\n", name)
		fprintf("type %s[T num.Primitive] = %sTyped[%s]\n\n", name, name, strings.Join(typesLike, ", "))
	}

	// Asymmetrically-typed
	fprintf("// %s is a %vD vector of asymmetrically typed bounded.Numeric components.\n", nameTyped, dim)
	if len(componentsUpper) > 1 {
		fprintf("//\n")
		fprintf("// NOTE: If you'd like symmetric types, please see %s.\n", name)
	}
	fprintf("type %s[%s num.Primitive] struct {\n", nameTyped, strings.Join(types, " num.Primitive, "))
	fprintf("\tEntity\n")
	for i, c := range componentsUpper {
		fprintf("\t%s bounded.Numeric[%s]\n", c, types[i])
	}
	fprintf("}\n\n")
}

func buildNewFuncs() {
	if name[0] == '_' {
		return
	}

	// Symmetrically-typed
	if len(componentsUpper) > 1 {
		fprintf("func New%s[T num.Primitive](", name)
		for i := 0; i < len(componentsUpper); i++ {
			if i == 0 {
				fprintf("%s T", componentsLower[i])
			} else {
				fprintf(", %s T", componentsLower[i])
			}
		}
		fprintf(", name ...string) *%s[T] {\n", name)
		fprintf("\ttyped := %s[T](*New%sTyped[%s](", name, name, strings.Join(typesLike, ", "))
		for i := 0; i < len(componentsUpper); i++ {
			if i == 0 {
				fprintf("%s", componentsLower[i])
			} else {
				fprintf(", %s", componentsLower[i])
			}
		}
		fprintf(", name...))\n")
		fprintf("\treturn &typed\n")
		fprintf("}\n\n")
	}

	// Asymmetrically-typed
	fprintf("func New%s[%s num.Primitive](", nameTyped, strings.Join(types, " num.Primitive, "))
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("%s T%s", componentsLower[i], componentsUpper[i])
		} else {
			fprintf(", %s T%s", componentsLower[i], componentsUpper[i])
		}
	}
	fprintf(", name ...string) *%s[%s] {\n", nameTyped, strings.Join(types, ", "))
	for _, c := range componentsUpper {
		fprintf("\tmin%s := num.MinValue[T%s]()\n", c, c)
		fprintf("\tmax%s := num.MaxValue[T%s]()\n", c, c)
		fprintf("\tif num.IsFloat[T%s]() {\n", c)
		fprintf("\t\tmin%s = 0\n", c)
		fprintf("\t\tmax%s = 1\n", c)
		fprintf("\t}\n")
	}
	fprintf("\n")
	fprintf("\t_v := &%s[%s]{}\n", nameTyped, strings.Join(types, ", "))
	fprintf("\t_v.Entity = NewEntity[format.Default]()\n")
	fprintf("\t_v.SetBoundaries(")
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("min%s, max%s", componentsUpper[i], componentsUpper[i])
		} else {
			fprintf(", min%s, max%s", componentsUpper[i], componentsUpper[i])
		}
	}
	fprintf(")\n")
	fprintf("\t_v.Set(%s)\n", strings.Join(componentsLower, ", "))
	fprintf("\tif len(name) > 0 {\n")
	fprintf("\t\t_v.SetName(name[0])\n")
	fprintf("\t}\n")
	fprintf("\treturn _v\n")
	fprintf("}\n\n")
}

func buildStringFunc() {
	/**
	First branch
	*/
	fprintf("func (_v %s[%s]) String() string {\n", nameTyped, strings.Join(types, ", "))

	fprintf("\tif atlas.CompactVectors {\n")
	fprintf("\t\treturn fmt.Sprintf(\"{")
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("%s: %%v", componentsLower[i])
		} else {
			fprintf(", %s: %%v", componentsLower[i])
		}
	}
	fprintf("}\"")
	for i := 0; i < len(componentsUpper); i++ {
		fprintf(", _v.%s.String()", componentsUpper[i])
	}
	fprintf(")\n\t}\n")

	fprintf("\t if support.AllSameTypes(")
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("T%s(0)", componentsUpper[i])
		} else {
			fprintf(", T%s(0)", componentsUpper[i])
		}
	}
	fprintf(") {\n")

	/**
	Second branch
	*/

	fprintf("\t\treturn fmt.Sprintf(\"%s[%%T]{", nameLower)
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("%%v")
		} else {
			fprintf(", %%v")
		}
	}
	fprintf("}(\\\"%%v\\\")\", T%s(0)", componentsUpper[0])
	for i := 0; i < len(componentsUpper); i++ {
		fprintf(", _v.%s.String()", componentsUpper[i])
	}
	fprintf(", _v.GivenName.Name)\n")
	fprintf("\t}\n")

	/**
	Michelle Branch
	*/

	fprintf("\treturn fmt.Sprintf(\"%s[", nameLower)
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("%%T")
		} else {
			fprintf(", %%T")
		}
	}
	fprintf("]{")

	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("%%v")
		} else {
			fprintf(", %%v")
		}
	}
	fprintf("}(\\\"%%v\\\")\"")
	for i := 0; i < len(componentsUpper); i++ {
		fprintf(", T%s(0)", componentsUpper[i])
	}
	for i := 0; i < len(componentsUpper); i++ {
		fprintf(", _v.%s.String()", componentsUpper[i])
	}
	fprintf(", _v.GivenName.Name)\n")
	fprintf("}\n\n")
}

func buildSetFunc() {
	fprintf("func (_v *%s[%s]) Set(", nameTyped, strings.Join(types, ", "))
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("%s T%s", componentsLower[i], componentsUpper[i])
		} else {
			fprintf(", %s T%s", componentsLower[i], componentsUpper[i])
		}
	}
	fprintf(") *%s[", nameTyped)
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("T%s", componentsUpper[i])
		} else {
			fprintf(", T%s", componentsUpper[i])
		}
	}
	fprintf("] {\n")
	for i, c := range componentsUpper {
		fprintf("\t_ = _v.%s.Set(%s)\n", c, componentsLower[i])
	}
	fprintf("\treturn _v\n")
	fprintf("}\n\n")
}

func buildSetClampFunc() {
	fprintf("func (_v *%s[%s]) SetClamp(clamp bool) *%s[", nameTyped, strings.Join(types, ", "), nameTyped)
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("T%s", componentsUpper[i])
		} else {
			fprintf(", T%s", componentsUpper[i])
		}
	}
	fprintf("] {\n")
	for _, c := range componentsUpper {
		fprintf("\t_v.%s.Clamp = clamp\n", c)
	}
	fprintf("\treturn _v\n")
	fprintf("}\n\n")
}

func buildSetBoundaries() {
	fprintf("func (_v *%s[%s]) SetBoundaries(", nameTyped, strings.Join(types, ", "))
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("min%s, max%s T%s", componentsUpper[i], componentsUpper[i], componentsUpper[i])
		} else {
			fprintf(", min%s, max%s T%s", componentsUpper[i], componentsUpper[i], componentsUpper[i])
		}
	}
	fprintf(") *%s[", nameTyped)
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("T%s", componentsUpper[i])
		} else {
			fprintf(", T%s", componentsUpper[i])
		}
	}
	fprintf("] {\n")
	for _, c := range componentsUpper {
		fprintf("\t_ = _v.%s.SetBoundaries(min%s, max%s)\n", c, c, c)
	}
	fprintf("\treturn _v\n")
	fprintf("}\n\n")
}

func buildSwizzleFuncs() {
	if len(componentsUpper) < 2 {
		return
	}

	components := make([]string, len(componentsUpper))

	var ii = 0
	for i := 0; i < len(componentsUpper); i++ {
		components[i] = componentsUpper[ii]
		ii++
		if ii == len(componentsUpper) {
			ii = 0
		}
	}

	for k := 2; k <= swizzleMax; k++ {
		cur := make([]string, 0, k)

		var recurse func()
		recurse = func() {
			if len(cur) == k {
				buildSwizzleFunc(cur...)
				return
			}
			for i := 0; i < len(componentsUpper); i++ {
				cur = append(cur, components[i])
				recurse()
				cur = cur[:len(cur)-1]
			}
		}
		recurse()
	}
}

func buildSwizzleFunc(components ...string) {
	fprintf("func (_v *%s[%s]) %s() (", nameTyped, strings.Join(types, ", "), strings.Join(components, ""))
	for i, c := range components {
		if i == 0 {
			fprintf("T%s", c)
		} else {
			fprintf(", T%s", c)
		}
	}
	fprintf(") { return ")
	for i, c := range components {
		if i == 0 {
			fprintf("_v.%s.Value()", c)
		} else {
			fprintf(", _v.%s.Value()", c)
		}
	}
	fprintf(" }\n")
}

func buildName() {
	fprintf("func (_v *%s[", nameTyped)
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("T%s", componentsUpper[i])
		} else {
			fprintf(", T%s", componentsUpper[i])
		}
	}
	fprintf("]) Name() string {\n")
	fprintf("\treturn _v.GivenName.Name\n")
	fprintf("}\n\n")
}

func buildSetName() {
	fprintf("func (_v *%s[", nameTyped)
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("T%s", componentsUpper[i])
		} else {
			fprintf(", T%s", componentsUpper[i])
		}
	}
	fprintf("]) SetName(name string) *%s[", nameTyped)
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("T%s", componentsUpper[i])
		} else {
			fprintf(", T%s", componentsUpper[i])
		}
	}
	fprintf("] {\n")
	fprintf("\t_v.GivenName.Name = name\n")
	fprintf("\treturn _v\n")
	fprintf("}\n\n")
}

func buildComponents() {
	fprintf("func (_v *%s[", nameTyped)
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("T%s", componentsUpper[i])
		} else {
			fprintf(", T%s", componentsUpper[i])
		}
	}
	fprintf("]) Components() []bounded.INumeric {\n")
	fprintf("\treturn []bounded.INumeric{")
	for i, c := range componentsUpper {
		if i == 0 {
			fprintf("&_v.%s", c)
		} else {
			fprintf(", &_v.%s", c)
		}
	}
	fprintf("}\n")
	fprintf("}\n\n")
}

func buildSetComponents() {
	fprintf("func (_v *%s[", nameTyped)
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("T%s", componentsUpper[i])
		} else {
			fprintf(", T%s", componentsUpper[i])
		}
	}
	fprintf("]) SetComponents(values []any) error {\n")
	fprintf("\tif len(values) != %d {\n", len(componentsUpper))
	fprintf("\t\treturn fmt.Errorf(\"cannot set %%d components of %dD vector %s\", len(values), )\n", len(componentsUpper), name)
	fprintf("\t}\n")
	for i := 0; i < len(componentsUpper); i++ {
		fprintf("\tif _, ok := values[%d].(T%s); !ok {\n", i, componentsUpper[i])
		fprintf("\t\treturn fmt.Errorf(\"expected type %%T for component %s, got type %%T\", T%s(0), values[%d])", componentsUpper[i], componentsUpper[i], i)
		fprintf("\t}\n")
	}
	for i := 0; i < len(componentsUpper); i++ {
		fprintf("\t_v.%s.Set(values[%d].(T%s))\n", componentsUpper[i], i, componentsUpper[i])
	}
	fprintf("\treturn nil\n")
	fprintf("}\n\n")
}

func buildComponentLen() {
	fprintf("func (_v *%s[", nameTyped)
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("T%s", componentsUpper[i])
		} else {
			fprintf(", T%s", componentsUpper[i])
		}
	}
	fprintf("]) ComponentLen() uint {\n")
	fprintf("\treturn %d\n", len(componentsUpper))
	fprintf("}\n\n")
}

func buildComponent() {
	fprintf("func (_v *%s[", nameTyped)
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("T%s", componentsUpper[i])
		} else {
			fprintf(", T%s", componentsUpper[i])
		}
	}
	fprintf("]) Component(index uint) (bounded.INumeric, error) {\n")
	fprintf("\tswitch index {\n")
	for i := 0; i < len(componentsUpper); i++ {
		fprintf("\tcase %d:\n", i)
		fprintf("\t\treturn &_v.%s, nil\n", componentsUpper[i])
	}
	fprintf("\tdefault:\n")
	fprintf("\t\treturn nil, fmt.Errorf(\"cannot get component index %%d of an %s vector\", index)\n", name)
	fprintf("\t}\n}\n\n")
}

func buildComponentByName() {
	fprintf("func (_v *%s[", nameTyped)
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("T%s", componentsUpper[i])
		} else {
			fprintf(", T%s", componentsUpper[i])
		}
	}
	fprintf("]) ComponentByName(name string) (bounded.INumeric, error) {\n")
	fprintf("\tswitch strings.ToLower(name) {\n")
	for i := 0; i < len(componentsUpper); i++ {
		fprintf("\tcase \"%s\":\n", strings.ToLower(componentsLower[i]))
		fprintf("\t\treturn &_v.%s, nil\n", componentsUpper[i])
	}
	fprintf("\tdefault:\n")
	fprintf("\t\treturn nil, fmt.Errorf(\"cannot get component \\\"%%s\\\" of an %s vector\", name)\n", name)
	fprintf("\t}\n}\n\n")
}

func buildSetComponent() {
	fprintf("func (_v *%s[", nameTyped)
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("T%s", componentsUpper[i])
		} else {
			fprintf(", T%s", componentsUpper[i])
		}
	}
	fprintf("]) SetComponent(index uint, value any) error {\n")
	fprintf("\tswitch index {\n")
	for i := 0; i < len(componentsUpper); i++ {
		fprintf("\tcase %d:\n", i)
		fprintf("\t\t _v.%s.Set(value.(T%s))\n", componentsUpper[i], componentsUpper[i])
	}
	fprintf("\tdefault:\n")
	fprintf("\t\treturn fmt.Errorf(\"cannot set component index %%d of an %s vector\", index)\n", name)
	fprintf("\t}\n")
	fprintf("\treturn nil\n")
	fprintf("}\n\n")
}

func buildSetComponentByName() {
	fprintf("func (_v *%s[", nameTyped)
	for i := 0; i < len(componentsUpper); i++ {
		if i == 0 {
			fprintf("T%s", componentsUpper[i])
		} else {
			fprintf(", T%s", componentsUpper[i])
		}
	}
	fprintf("]) SetComponentByName(name string, value any) error {\n")
	fprintf("\tswitch strings.ToLower(name) {\n")
	for i := 0; i < len(componentsUpper); i++ {
		fprintf("\tcase \"%s\":\n", strings.ToLower(componentsLower[i]))
		fprintf("\t\t _v.%s.Set(value.(T%s))\n", componentsUpper[i], componentsUpper[i])
	}
	fprintf("\tdefault:\n")
	fprintf("\t\treturn fmt.Errorf(\"cannot set component \\\"%%s\\\" of an %s vector\", name)\n", name)
	fprintf("\t}\n")
	fprintf("\treturn nil\n")
	fprintf("}\n\n")
}
