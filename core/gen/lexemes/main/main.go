package main

import (
	"flag"
	"fmt"
	"os"
	"strings"
)

const NotExhaustive = "NOTE: This list is not necessarily exhaustive!"

var newlineAt = 7
var lexiconName string
var out string
var in string
var b *strings.Builder

var lexicon *Lexicon

func fprintf(format string, a ...any) {
	_, _ = fmt.Fprintf(b, format, a...)
}

func main() {
	flag.StringVar(&lexiconName, "lexicon", "", "")
	flag.StringVar(&in, "in", "", "")
	flag.StringVar(&out, "out", "", "")
	flag.Parse()

	b = new(strings.Builder)

	var err error
	lexicon, err = ParseJSON(in)
	if err != nil {
		fmt.Fprintf(os.Stderr, "lexeme parsing: %v\n", err)
		os.Exit(1)
	}

	if err = run(); err != nil {
		fmt.Fprintf(os.Stderr, "lexeme generation: %v\n", err)
		os.Exit(1)
	}
}

func fprintfDocs(docs string, related ...string) {
	for _, line := range strings.Split(docs, "\n") {
		fprintf("// %s\n", line)
	}

	if len(related) > 0 {
		fprintf("//\n")

		for _, line := range strings.Split(related[0], "\n") {
			fprintf("// %s\n", line)
		}
	}
}

func run() error {
	fprintf("// Code generated by 'gen/lexemes/main'; DO NOT EDIT.\n")
	fprintf("package %s\n\n", lexiconName)

	for _, t := range lexicon.Types {
		if len(t.Set) > 0 {
			fprintf("import \"core/std\"\n\n")
			break
		}
	}

	fprintfDocs(lexicon.Docs, lexicon.Related)
	fprintf("type Lexeme struct {\n\t%s %s\n}\n\n", lexicon.Lexeme, lexicon.Type)

	for _, t := range lexicon.Types {
		fprintfDocs(t.Docs)

		if len(t.NameSet) > 0 {
			fprintfDocs(fmt.Sprintf("\n- See %s\n", t.NameSet))
		}

		fprintfDocs(lexicon.Related)

		if t.Base != "" {
			fprintf("type %s %s\n\n", t.Name, t.Base)
			fprintf("func (t %s) String() string { return %s(t).String() } \n\n", t.Name, t.Base)
		} else {
			fprintf("type %s Lexeme\n\n", t.Name)
			fprintf("func (t %s) String() string { return Lexeme(t).String() } \n\n", t.Name)
		}

		if len(t.NameSet) > 0 && len(t.Set) > 0 {
			if t.Exhaustive {
				fprintfDocs(fmt.Sprintf("%s - see %s", t.NameSet, t.Name))
			} else {
				fprintfDocs(fmt.Sprintf("%s - see %s", t.NameSet, t.Name), NotExhaustive)
			}
			fprintf("var %s = []%s{\n\t", t.NameSet, t.Name)

			ii := 0
			for i := 0; i < len(t.Set); i++ {
				if t.Set[i] == "\"" {
					t.Set[i] = "\\\""
				}

				fprintf("{\"%s\"},", t.Set[i])
				ii++
				if ii >= newlineAt && i < len(t.Set)-1 {
					fprintf("\n\t")
					ii = 0
				}
			}
			fprintf("\n}\n\n")

			fprintf("// Is%s tests if the provided Lexeme is a %s.\n", t.Name, t.Name)
			fprintf("func Is%s(l std.Lexeme) bool {\n", t.Name)
			fprintf("\tfor _, t := range %s {\n", t.NameSet)
			fprintf("\t\tif t.String() == l.String() {\n")
			fprintf("\t\t\treturn true\n")
			fprintf("\t\t}\n")
			fprintf("\t}\n")
			fprintf("\treturn false\n")
			fprintf("}\n\n")
		}

		if len(t.Alias) > 0 {
			aliasDocs := strings.Replace(t.Docs, t.Name, t.Alias, 1)

			fprintfDocs(aliasDocs, lexicon.Related)
			fprintf("type %s = %s\n\n", t.Alias, t.Name)
		}
	}
	return os.WriteFile(out, []byte(b.String()), 0o644)
}
