package main

import (
	"flag"
	"fmt"
	"os"
	"slices"
	"strings"
)

const NotExhaustive = "NOTE: This list is not necessarily exhaustive!"

var newlineAt = 7
var lexiconName string
var out string
var in string
var b *strings.Builder

var lexicon *Lexicon

func fprintf(format string, a ...any) {
	_, _ = fmt.Fprintf(b, format, a...)
}

func main() {
	flag.StringVar(&lexiconName, "lexicon", "", "")
	flag.StringVar(&in, "in", "", "")
	flag.StringVar(&out, "out", "", "")
	flag.Parse()

	b = new(strings.Builder)

	var err error
	lexicon, err = ParseJSON(in)
	if err != nil {
		fmt.Fprintf(os.Stderr, "lexeme parsing: %v\n", err)
		os.Exit(1)
	}

	if err = run(); err != nil {
		fmt.Fprintf(os.Stderr, "lexeme generation: %v\n", err)
		os.Exit(1)
	}
}

func fprintfDocs(docs []string, related ...string) {
	for _, line := range docs {
		fprintf("// %s\n", line)
	}

	if len(related) > 0 {
		fprintf("//\n")

		for _, line := range related {
			fprintf("// %s\n", line)
		}
	}
}

func run() error {
	fprintf("// Code generated by 'gen/lexemes/main'; DO NOT EDIT.\n")
	fprintf("package %s\n\n", lexiconName)

	for _, t := range lexicon.Types {
		if len(t.Set) > 0 {
			fprintf("import \"core/std\"\n\n")
			break
		}
	}

	for _, t := range lexicon.Types {
		fprintfDocs(t.Docs)

		if len(t.NameSet) > 0 {
			fprintfDocs([]string{"", fmt.Sprintf("- See %s\n//", t.NameSet)})
		}

		fprintfDocs(lexicon.Related)

		if t.Base != "" {
			fprintf("type %s %s\n\n", t.Name, t.Base)
		} else {
			fprintf("type %s Lexeme\n\n", t.Name)
		}

		if len(t.NameSet) > 0 && len(t.Set) > 0 {
			if t.Exhaustive {
				fprintfDocs([]string{fmt.Sprintf("%s - see %s", t.NameSet, t.Name)})
			} else {
				fprintfDocs([]string{fmt.Sprintf("%s - see %s", t.NameSet, t.Name)}, NotExhaustive)
			}
			fprintf("var %s = map[string]%s{\n\t", t.NameSet, t.Name)

			for k, v := range t.Set {
				if k == "\"" {
					k = "\\\""
				}

				fprintf("\t\"%s\": %s(\"%s\"),\n", k, t.Name, v)
			}
			fprintf("}\n\n")

			fprintf("// Is%s tests if the provided Lexeme is a %s.\n", t.Name, t.Name)
			fprintf("func Is%s(l std.Lexeme) bool {\n", t.Name)
			fprintf("\tif _, ok := %s[l.String()]; ok {\n", t.NameSet)
			fprintf("\t\treturn true\n")
			fprintf("\t}\n")
			fprintf("\treturn false\n")
			fprintf("}\n\n")
		}

		if len(t.Alias) > 0 {
			aliasDocs := slices.Clone(t.Docs)
			for i, d := range aliasDocs {
				aliasDocs[i] = strings.Replace(d, t.Name, t.Alias, 1)
			}

			fprintfDocs(aliasDocs, lexicon.Related...)
			fprintf("type %s = %s\n\n", t.Alias, t.Name)
		}
	}
	return os.WriteFile(out, []byte(b.String()), 0o644)
}
