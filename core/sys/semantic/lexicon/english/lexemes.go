// Code generated by 'gen/lexemes/main'; DO NOT EDIT.
package english

import "core/std"

// Lexeme is the most basic unit of the English lexicon.  The English lexicon begins with
// a "Lemma" string - named so from the English WordNet database which drives it.
//
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type Lexeme struct {
	Lemma string
}

// Prototype is a Lexeme of unknown classification.  This collection should be used as a source from which to evolve a Lexicon over time.
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type Prototype Lexeme

func (t Prototype) String() string { return t.Lemma } 

// PunctuationMark represents an English punctuation mark, such as '!' or '?'
// 
// - See PunctuationMarks
// 
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type PunctuationMark Lexeme

func (t PunctuationMark) String() string { return t.Lemma } 

// PunctuationMarks - see PunctuationMark
//
// NOTE: This list is not necessarily exhaustive!
var PunctuationMarks = []PunctuationMark{
	{"."},{","},{"?"},{"!"},{":"},{";"},{"("},
	{")"},{"["},{"]"},
}

// IsPunctuationMark tests if the provided Lexeme is a PunctuationMark.
func IsPunctuationMark(l std.Lexeme) bool {
	for _, t := range PunctuationMarks {
		if t.String() == l.String() {
			return true
		}
	}
	return false
}

// Quote represents an English quote character
// 
// - See Quotes
// 
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type Quote Lexeme

func (t Quote) String() string { return t.Lemma } 

// Quotes - see Quote
//
// NOTE: This list is not necessarily exhaustive!
var Quotes = []Quote{
	{"`"},{"'"},{"\""},
}

// IsQuote tests if the provided Lexeme is a Quote.
func IsQuote(l std.Lexeme) bool {
	for _, t := range Quotes {
		if t.String() == l.String() {
			return true
		}
	}
	return false
}

// Dash represents an English dash character
// 
// - See Dashes
// 
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type Dash Lexeme

func (t Dash) String() string { return t.Lemma } 

// Dashes - see Dash
//
// NOTE: This list is not necessarily exhaustive!
var Dashes = []Dash{
	{"-"},{"–"},{"—"},{"―"},{"﹘"},{"﹣"},{"－"},
}

// IsDash tests if the provided Lexeme is a Dash.
func IsDash(l std.Lexeme) bool {
	for _, t := range Dashes {
		if t.String() == l.String() {
			return true
		}
	}
	return false
}

// ControlCharacter represents a special controlling character such as 'newline' or 'tab'.
// 
// - See ControlCharacters
// 
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type ControlCharacter Lexeme

func (t ControlCharacter) String() string { return t.Lemma } 

// ControlCharacters - see ControlCharacter
//
// NOTE: This list is not necessarily exhaustive!
var ControlCharacters = []ControlCharacter{
	{"\n"},{"\t"},{"\r"},{"\b"},{"\f"},{"\v"},{"\a"},
}

// IsControlCharacter tests if the provided Lexeme is a ControlCharacter.
func IsControlCharacter(l std.Lexeme) bool {
	for _, t := range ControlCharacters {
		if t.String() == l.String() {
			return true
		}
	}
	return false
}

// Function words are the semantic glue that holds language together.  They compose of many different categories,
// each of which is a type of function word.  If you wish to describe 'any function word' use this interface - otherwise
// you may describe it using the below references:
// 
// - AuxiliaryVerb, Conjunction, Preposition, Determiner, Pronoun, Quantifier, and Particle.
// 
// NOTE: Function words are always stored in lowercase form for disambiguation.
// 
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type Function Lexeme

func (t Function) String() string { return t.Lemma } 

// An AuxiliaryVerb helps a main verb to express tense, mood, or voice
// 
// - AuxiliaryVerb, Conjunction, Preposition, Determiner, Pronoun, Quantifier, and Particle
// 
// - See AuxiliaryVerbs
// 
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type AuxiliaryVerb Function

func (t AuxiliaryVerb) String() string { return t.Lemma } 

// AuxiliaryVerbs - see AuxiliaryVerb
//
// NOTE: This list is not necessarily exhaustive!
var AuxiliaryVerbs = []AuxiliaryVerb{
	{"be"},{"am"},{"is"},{"are"},{"was"},{"were"},{"being"},
	{"been"},{"have"},{"has"},{"had"},{"having"},{"do"},{"does"},
	{"did"},{"will"},{"can"},{"could"},{"may"},{"might"},{"must"},
	{"would"},{"shall"},{"should"},
}

// IsAuxiliaryVerb tests if the provided Lexeme is a AuxiliaryVerb.
func IsAuxiliaryVerb(l std.Lexeme) bool {
	for _, t := range AuxiliaryVerbs {
		if t.String() == l.String() {
			return true
		}
	}
	return false
}

// A Conjunction links together words, phrases, or clauses of equal or unequal grammatical rank
// 
// - AuxiliaryVerb, Conjunction, Preposition, Determiner, Pronoun, Quantifier, and Particle
// 
// - See Conjunctions
// 
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type Conjunction Function

func (t Conjunction) String() string { return t.Lemma } 

// Conjunctions - see Conjunction
//
// NOTE: This list is not necessarily exhaustive!
var Conjunctions = []Conjunction{
	{"and"},{"but"},{"or"},{"not"},{"so"},{"yet"},{"for"},
	{"although"},{"because"},{"since"},{"unless"},{"while"},{"whereas"},{"if"},
	{"though"},
}

// IsConjunction tests if the provided Lexeme is a Conjunction.
func IsConjunction(l std.Lexeme) bool {
	for _, t := range Conjunctions {
		if t.String() == l.String() {
			return true
		}
	}
	return false
}

// A Preposition establishes a relationship, typically spatial or temporal, between a noun or pronoun and another word
// 
// - AuxiliaryVerb, Conjunction, Preposition, Determiner, Pronoun, Quantifier, and Particle
// 
// - See Prepositions
// 
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type Preposition Function

func (t Preposition) String() string { return t.Lemma } 

// Prepositions - see Preposition
//
// NOTE: This list is not necessarily exhaustive!
var Prepositions = []Preposition{
	{"of"},{"to"},{"in"},{"on"},{"at"},{"by"},{"for"},
	{"with"},{"about"},{"over"},{"under"},{"between"},{"through"},{"during"},
	{"against"},{"among"},{"across"},{"behind"},{"beyond"},{"inside"},{"outside"},
	{"without"},{"within"},{"upon"},
}

// IsPreposition tests if the provided Lexeme is a Preposition.
func IsPreposition(l std.Lexeme) bool {
	for _, t := range Prepositions {
		if t.String() == l.String() {
			return true
		}
	}
	return false
}

// A Determiner specifies the reference of a noun, providing context about its quantity, definiteness, or ownership
// 
// - AuxiliaryVerb, Conjunction, Preposition, Determiner, Pronoun, Quantifier, and Particle
// 
// - See Determiners
// 
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type Determiner Function

func (t Determiner) String() string { return t.Lemma } 

// Determiners - see Determiner
//
// NOTE: This list is not necessarily exhaustive!
var Determiners = []Determiner{
	{"a"},{"an"},{"the"},{"this"},{"that"},{"these"},{"those"},
	{"my"},{"your"},{"his"},{"her"},{"its"},{"our"},{"their"},
	{"some"},{"any"},{"no"},{"each"},{"every"},{"either"},{"neither"},
	{"much"},{"many"},{"few"},{"several"},{"all"},{"both"},
}

// IsDeterminer tests if the provided Lexeme is a Determiner.
func IsDeterminer(l std.Lexeme) bool {
	for _, t := range Determiners {
		if t.String() == l.String() {
			return true
		}
	}
	return false
}

// A Pronoun substitutes for a noun or noun phrase, often to prevent repetition
// 
// - AuxiliaryVerb, Conjunction, Preposition, Determiner, Pronoun, Quantifier, and Particle
// 
// - See Pronouns
// 
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type Pronoun Function

func (t Pronoun) String() string { return t.Lemma } 

// Pronouns - see Pronoun
//
// NOTE: This list is not necessarily exhaustive!
var Pronouns = []Pronoun{
	{"I"},{"you"},{"he"},{"she"},{"it"},{"we"},{"they"},
	{"me"},{"him"},{"her"},{"us"},{"them"},{"myself"},{"yourself"},
	{"himself"},{"herself"},{"itself"},{"ourselves"},{"yourselves"},{"themselves"},{"who"},
	{"whom"},{"whose"},{"which"},{"what"},{"anyone"},{"someone"},{"everyone"},
	{"nobody"},{"nothing"},{"anything"},{"everything"},
}

// IsPronoun tests if the provided Lexeme is a Pronoun.
func IsPronoun(l std.Lexeme) bool {
	for _, t := range Pronouns {
		if t.String() == l.String() {
			return true
		}
	}
	return false
}

// A Quantifier indicates the quantity or amount of a noun without being a specific number
// 
// - AuxiliaryVerb, Conjunction, Preposition, Determiner, Pronoun, Quantifier, and Particle
// 
// - See Quantifiers
// 
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type Quantifier Function

func (t Quantifier) String() string { return t.Lemma } 

// Quantifiers - see Quantifier
//
// NOTE: This list is not necessarily exhaustive!
var Quantifiers = []Quantifier{
	{"few"},{"little"},{"much"},{"many"},{"several"},{"all"},{"some"},
	{"any"},{"enough"},{"more"},{"most"},{"less"},{"least"},
}

// IsQuantifier tests if the provided Lexeme is a Quantifier.
func IsQuantifier(l std.Lexeme) bool {
	for _, t := range Quantifiers {
		if t.String() == l.String() {
			return true
		}
	}
	return false
}

// A Particle modifies or connects other parts of a phrase
// 
// - AuxiliaryVerb, Conjunction, Preposition, Determiner, Pronoun, Quantifier, and Particle
// 
// - See Particles
// 
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type Particle Function

func (t Particle) String() string { return t.Lemma } 

// Particles - see Particle
//
// NOTE: This list is not necessarily exhaustive!
var Particles = []Particle{
	{"not"},{"no"},{"nor"},{"only"},{"just"},{"even"},{"still"},
	{"yet"},{"already"},{"also"},{"too"},{"there"},{"here"},{"then"},
	{"now"},{"how"},{"when"},{"where"},{"why"},{"yes"},{"no"},
	{"okay"},{"well"},
}

// IsParticle tests if the provided Lexeme is a Particle.
func IsParticle(l std.Lexeme) bool {
	for _, t := range Particles {
		if t.String() == l.String() {
			return true
		}
	}
	return false
}

