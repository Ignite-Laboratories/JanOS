// Code generated by 'gen/lexemes/main'; DO NOT EDIT.
package english

import "core/std"

// Prototype is a Lexeme of unknown classification.  This collection should be used as a source from which to evolve a Lexicon over time.
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type Prototype Lexeme

// PunctuationMark represents an English punctuation mark, such as '!' or '?'
// 
// - See PunctuationMarks
//
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type PunctuationMark Lexeme

// PunctuationMarks - see PunctuationMark
//
// NOTE: This list is not necessarily exhaustive!
var PunctuationMarks = map[string]PunctuationMark{
		",": PunctuationMark("ASCII Comma (U+002C)"),
	"?": PunctuationMark("ASCII Question Mark (U+003F)"),
	"!": PunctuationMark("ASCII Exclamation Mark (U+0021)"),
	")": PunctuationMark("ASCII Right Parenthesis (U+0029)"),
	"{": PunctuationMark("ASCII Left Curly Bracket (Brace) (U+007B)"),
	"}": PunctuationMark("ASCII Right Curly Bracket (Brace) (U+007D)"),
	".": PunctuationMark("ASCII Full Stop (Period) (U+002E)"),
	":": PunctuationMark("ASCII Colon (U+003A)"),
	";": PunctuationMark("ASCII Semicolon (U+003B)"),
	"(": PunctuationMark("ASCII Left Parenthesis (U+0028)"),
	"[": PunctuationMark("ASCII Left Square Bracket (U+005B)"),
	"]": PunctuationMark("ASCII Right Square Bracket (U+005D)"),
}

// IsPunctuationMark tests if the provided Lexeme is a PunctuationMark.
func IsPunctuationMark(l std.Lexeme) bool {
	if _, ok := PunctuationMarks[l.String()]; ok {
		return true
	}
	return false
}

// Operator represents an arithmetic operator, such as '+' or '-'
// 
// - See Operators
//
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type Operator Lexeme

// Operators - see Operator
//
// NOTE: This list is not necessarily exhaustive!
var Operators = map[string]Operator{
		"/": Operator("ASCII Solidus (Slash) (U+002F)"),
	"*": Operator("ASCII Asterisk (U+002A)"),
	"%": Operator("ASCII Percent Sign (U+0025)"),
	"^": Operator("ASCII Circumflex Accent (Caret) (U+005E)"),
	"+": Operator("ASCII Plus Sign (U+002B)"),
	"-": Operator("ASCII Hyphen-Minus (U+002D)"),
}

// IsOperator tests if the provided Lexeme is a Operator.
func IsOperator(l std.Lexeme) bool {
	if _, ok := Operators[l.String()]; ok {
		return true
	}
	return false
}

// Quote represents a quote character
// 
// - See Quotes
//
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type Quote Lexeme

// Quotes - see Quote
//
// NOTE: This list is not necessarily exhaustive!
var Quotes = map[string]Quote{
		"`": Quote("ASCII Grave Accent (Backtick) (U+0060)"),
	"'": Quote("ASCII Apostrophe (Single Quote) (U+0027)"),
	"\"": Quote("ASCII Quotation Mark (Double Quote) (U+0022)"),
}

// IsQuote tests if the provided Lexeme is a Quote.
func IsQuote(l std.Lexeme) bool {
	if _, ok := Quotes[l.String()]; ok {
		return true
	}
	return false
}

// Dash represents a dash character
// 
// - See Dashes
//
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type Dash Lexeme

// Dashes - see Dash
//
// NOTE: This list is not necessarily exhaustive!
var Dashes = map[string]Dash{
		"―": Dash("Horizontal Bar (Quotation Dash) — General Punctuation (U+2015)"),
	"-": Dash("ASCII Hyphen-Minus (U+002D)"),
	"﹣": Dash("Small Hyphen-Minus — CJK Small Form (U+FE63)"),
	"－": Dash("Fullwidth Hyphen-Minus — CJK Fullwidth (U+FF0D)"),
	"–": Dash("EN Dash — General Punctuation (U+2013)"),
	"﹘": Dash("Small EM Dash — CJK Small Form (U+FE58)"),
	"—": Dash("EM Dash — General Punctuation (U+2014)"),
}

// IsDash tests if the provided Lexeme is a Dash.
func IsDash(l std.Lexeme) bool {
	if _, ok := Dashes[l.String()]; ok {
		return true
	}
	return false
}

// ControlCharacter represents a special controlling character such as 'newline' or 'tab'.
// 
// - See ControlCharacters
//
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type ControlCharacter Lexeme

// ControlCharacters - see ControlCharacter
//
// NOTE: This list is not necessarily exhaustive!
var ControlCharacters = map[string]ControlCharacter{
		"\b": ControlCharacter("ASCII Backspace (BS) — C0 Control (U+0008)"),
	"\f": ControlCharacter("ASCII Form Feed (FF) — C0 Control (U+000C)"),
	"\v": ControlCharacter("ASCII Vertical Tab (VT) — C0 Control (U+000B)"),
	"\a": ControlCharacter("ASCII Bell (Alert, BEL) — C0 Control (U+0007)"),
	"\n": ControlCharacter("ASCII Line Feed (LF) — C0 Control (U+000A)"),
	"\t": ControlCharacter("ASCII Horizontal Tab (HT) — C0 Control (U+0009)"),
	"\r": ControlCharacter("ASCII Carriage Return (CR) — C0 Control (U+000D)"),
}

// IsControlCharacter tests if the provided Lexeme is a ControlCharacter.
func IsControlCharacter(l std.Lexeme) bool {
	if _, ok := ControlCharacters[l.String()]; ok {
		return true
	}
	return false
}

// Function words are the semantic glue that holds language together.  They compose of many different categories,
// each of which is a type of function word.  If you wish to describe 'any function word' use this interface - otherwise
// you may describe it using the below references:
// 
// - AuxiliaryVerb, Conjunction, Preposition, Determiner, Pronoun, Quantifier, and Particle.
// 
// NOTE: Function words are always stored in lowercase form for disambiguation.
// 
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type Function Lexeme

// An AuxiliaryVerb helps a main verb to express tense, mood, or voice
// 
// - AuxiliaryVerb, Conjunction, Preposition, Determiner, Pronoun, Quantifier, and Particle
// 
// - See AuxiliaryVerbs
//
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type AuxiliaryVerb Function

// AuxiliaryVerbs - see AuxiliaryVerb
//
// NOTE: This list is not necessarily exhaustive!
var AuxiliaryVerbs = map[string]AuxiliaryVerb{
		"is": AuxiliaryVerb("An auxiliary verb"),
	"was": AuxiliaryVerb("An auxiliary verb"),
	"had": AuxiliaryVerb("An auxiliary verb"),
	"could": AuxiliaryVerb("An auxiliary verb"),
	"does": AuxiliaryVerb("An auxiliary verb"),
	"be": AuxiliaryVerb("An auxiliary verb"),
	"being": AuxiliaryVerb("An auxiliary verb"),
	"been": AuxiliaryVerb("An auxiliary verb"),
	"have": AuxiliaryVerb("An auxiliary verb"),
	"has": AuxiliaryVerb("An auxiliary verb"),
	"did": AuxiliaryVerb("An auxiliary verb"),
	"can": AuxiliaryVerb("An auxiliary verb"),
	"having": AuxiliaryVerb("An auxiliary verb"),
	"do": AuxiliaryVerb("An auxiliary verb"),
	"may": AuxiliaryVerb("An auxiliary verb"),
	"might": AuxiliaryVerb("An auxiliary verb"),
	"must": AuxiliaryVerb("An auxiliary verb"),
	"would": AuxiliaryVerb("An auxiliary verb"),
	"shall": AuxiliaryVerb("An auxiliary verb"),
	"should": AuxiliaryVerb("An auxiliary verb"),
	"am": AuxiliaryVerb("An auxiliary verb"),
	"are": AuxiliaryVerb("An auxiliary verb"),
	"were": AuxiliaryVerb("An auxiliary verb"),
	"will": AuxiliaryVerb("An auxiliary verb"),
}

// IsAuxiliaryVerb tests if the provided Lexeme is a AuxiliaryVerb.
func IsAuxiliaryVerb(l std.Lexeme) bool {
	if _, ok := AuxiliaryVerbs[l.String()]; ok {
		return true
	}
	return false
}

// A Conjunction links together words, phrases, or clauses of equal or unequal grammatical rank
// 
// - AuxiliaryVerb, Conjunction, Preposition, Determiner, Pronoun, Quantifier, and Particle
// 
// - See Conjunctions
//
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type Conjunction Function

// Conjunctions - see Conjunction
//
// NOTE: This list is not necessarily exhaustive!
var Conjunctions = map[string]Conjunction{
		"although": Conjunction("A conjunction"),
	"though": Conjunction("A conjunction"),
	"or": Conjunction("A conjunction"),
	"since": Conjunction("A conjunction"),
	"unless": Conjunction("A conjunction"),
	"whereas": Conjunction("A conjunction"),
	"because": Conjunction("A conjunction"),
	"while": Conjunction("A conjunction"),
	"if": Conjunction("A conjunction"),
	"and": Conjunction("A conjunction"),
	"but": Conjunction("A conjunction"),
	"so": Conjunction("A conjunction"),
	"yet": Conjunction("A conjunction"),
	"for": Conjunction("A conjunction"),
	"not": Conjunction("A conjunction"),
}

// IsConjunction tests if the provided Lexeme is a Conjunction.
func IsConjunction(l std.Lexeme) bool {
	if _, ok := Conjunctions[l.String()]; ok {
		return true
	}
	return false
}

// A Preposition establishes a relationship, typically spatial or temporal, between a noun or pronoun and another word
// 
// - AuxiliaryVerb, Conjunction, Preposition, Determiner, Pronoun, Quantifier, and Particle
// 
// - See Prepositions
//
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type Preposition Function

// Prepositions - see Preposition
//
// NOTE: This list is not necessarily exhaustive!
var Prepositions = map[string]Preposition{
		"in": Preposition("A preposition"),
	"between": Preposition("A preposition"),
	"through": Preposition("A preposition"),
	"during": Preposition("A preposition"),
	"among": Preposition("A preposition"),
	"across": Preposition("A preposition"),
	"within": Preposition("A preposition"),
	"to": Preposition("A preposition"),
	"on": Preposition("A preposition"),
	"by": Preposition("A preposition"),
	"about": Preposition("A preposition"),
	"without": Preposition("A preposition"),
	"upon": Preposition("A preposition"),
	"of": Preposition("A preposition"),
	"at": Preposition("A preposition"),
	"for": Preposition("A preposition"),
	"over": Preposition("A preposition"),
	"against": Preposition("A preposition"),
	"behind": Preposition("A preposition"),
	"inside": Preposition("A preposition"),
	"with": Preposition("A preposition"),
	"under": Preposition("A preposition"),
	"beyond": Preposition("A preposition"),
	"outside": Preposition("A preposition"),
}

// IsPreposition tests if the provided Lexeme is a Preposition.
func IsPreposition(l std.Lexeme) bool {
	if _, ok := Prepositions[l.String()]; ok {
		return true
	}
	return false
}

// A Determiner specifies the reference of a noun, providing context about its quantity, definiteness, or ownership
// 
// - AuxiliaryVerb, Conjunction, Preposition, Determiner, Pronoun, Quantifier, and Particle
// 
// - See Determiners
//
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type Determiner Function

// Determiners - see Determiner
//
// NOTE: This list is not necessarily exhaustive!
var Determiners = map[string]Determiner{
		"an": Determiner("A determiner"),
	"this": Determiner("A determiner"),
	"these": Determiner("A determiner"),
	"those": Determiner("A determiner"),
	"my": Determiner("A determiner"),
	"her": Determiner("A determiner"),
	"its": Determiner("A determiner"),
	"our": Determiner("A determiner"),
	"no": Determiner("A determiner"),
	"each": Determiner("A determiner"),
	"either": Determiner("A determiner"),
	"neither": Determiner("A determiner"),
	"much": Determiner("A determiner"),
	"many": Determiner("A determiner"),
	"all": Determiner("A determiner"),
	"both": Determiner("A determiner"),
	"the": Determiner("A determiner"),
	"that": Determiner("A determiner"),
	"your": Determiner("A determiner"),
	"his": Determiner("A determiner"),
	"some": Determiner("A determiner"),
	"several": Determiner("A determiner"),
	"a": Determiner("A determiner"),
	"their": Determiner("A determiner"),
	"any": Determiner("A determiner"),
	"every": Determiner("A determiner"),
	"few": Determiner("A determiner"),
}

// IsDeterminer tests if the provided Lexeme is a Determiner.
func IsDeterminer(l std.Lexeme) bool {
	if _, ok := Determiners[l.String()]; ok {
		return true
	}
	return false
}

// A Pronoun substitutes for a noun or noun phrase, often to prevent repetition
// 
// - AuxiliaryVerb, Conjunction, Preposition, Determiner, Pronoun, Quantifier, and Particle
// 
// - See Pronouns
//
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type Pronoun Function

// Pronouns - see Pronoun
//
// NOTE: This list is not necessarily exhaustive!
var Pronouns = map[string]Pronoun{
		"it": Pronoun("A pronoun"),
	"yourselves": Pronoun("A pronoun"),
	"me": Pronoun("A pronoun"),
	"herself": Pronoun("A pronoun"),
	"someone": Pronoun("A pronoun"),
	"nobody": Pronoun("A pronoun"),
	"you": Pronoun("A pronoun"),
	"which": Pronoun("A pronoun"),
	"what": Pronoun("A pronoun"),
	"her": Pronoun("A pronoun"),
	"itself": Pronoun("A pronoun"),
	"who": Pronoun("A pronoun"),
	"whom": Pronoun("A pronoun"),
	"whose": Pronoun("A pronoun"),
	"anyone": Pronoun("A pronoun"),
	"nothing": Pronoun("A pronoun"),
	"everything": Pronoun("A pronoun"),
	"she": Pronoun("A pronoun"),
	"them": Pronoun("A pronoun"),
	"ourselves": Pronoun("A pronoun"),
	"everyone": Pronoun("A pronoun"),
	"anything": Pronoun("A pronoun"),
	"yourself": Pronoun("A pronoun"),
	"I": Pronoun("A pronoun"),
	"we": Pronoun("A pronoun"),
	"they": Pronoun("A pronoun"),
	"him": Pronoun("A pronoun"),
	"us": Pronoun("A pronoun"),
	"himself": Pronoun("A pronoun"),
	"he": Pronoun("A pronoun"),
	"myself": Pronoun("A pronoun"),
	"themselves": Pronoun("A pronoun"),
}

// IsPronoun tests if the provided Lexeme is a Pronoun.
func IsPronoun(l std.Lexeme) bool {
	if _, ok := Pronouns[l.String()]; ok {
		return true
	}
	return false
}

// A Quantifier indicates the quantity or amount of a noun without being a specific number
// 
// - AuxiliaryVerb, Conjunction, Preposition, Determiner, Pronoun, Quantifier, and Particle
// 
// - See Quantifiers
//
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type Quantifier Function

// Quantifiers - see Quantifier
//
// NOTE: This list is not necessarily exhaustive!
var Quantifiers = map[string]Quantifier{
		"much": Quantifier("A quantifier"),
	"several": Quantifier("A quantifier"),
	"all": Quantifier("A quantifier"),
	"some": Quantifier("A quantifier"),
	"enough": Quantifier("A quantifier"),
	"more": Quantifier("A quantifier"),
	"less": Quantifier("A quantifier"),
	"few": Quantifier("A quantifier"),
	"little": Quantifier("A quantifier"),
	"many": Quantifier("A quantifier"),
	"any": Quantifier("A quantifier"),
	"most": Quantifier("A quantifier"),
	"least": Quantifier("A quantifier"),
}

// IsQuantifier tests if the provided Lexeme is a Quantifier.
func IsQuantifier(l std.Lexeme) bool {
	if _, ok := Quantifiers[l.String()]; ok {
		return true
	}
	return false
}

// A Particle modifies or connects other parts of a phrase
// 
// - AuxiliaryVerb, Conjunction, Preposition, Determiner, Pronoun, Quantifier, and Particle
// 
// - See Particles
//
// See Lexeme, Prototype, PunctuationMark, Quote, Dash, Function, ControlCharacter, PartOfSpeech, and Synset
type Particle Function

// Particles - see Particle
//
// NOTE: This list is not necessarily exhaustive!
var Particles = map[string]Particle{
		"where": Particle("A particle"),
	"why": Particle("A particle"),
	"not": Particle("A particle"),
	"only": Particle("A particle"),
	"yet": Particle("A particle"),
	"too": Particle("A particle"),
	"well": Particle("A particle"),
	"nor": Particle("A particle"),
	"just": Particle("A particle"),
	"also": Particle("A particle"),
	"then": Particle("A particle"),
	"how": Particle("A particle"),
	"no": Particle("A particle"),
	"even": Particle("A particle"),
	"already": Particle("A particle"),
	"now": Particle("A particle"),
	"yes": Particle("A particle"),
	"okay": Particle("A particle"),
	"still": Particle("A particle"),
	"there": Particle("A particle"),
	"here": Particle("A particle"),
	"when": Particle("A particle"),
}

// IsParticle tests if the provided Lexeme is a Particle.
func IsParticle(l std.Lexeme) bool {
	if _, ok := Particles[l.String()]; ok {
		return true
	}
	return false
}

